<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice Roller with Tension Timers</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=League+Spartan:wght@400;500;600;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* CSS from your previous "FANTASTIC" version */
        :root {
        --bg-primary: #f8fafc;
        --bg-secondary: #ffffff;
        --bg-tertiary: #e9eff3;
        --text-primary: #2c3e50;
        --text-secondary: #526c84;
        --accent: #2980b9;
        --accent-secondary: #8e44ad;
        --border: #d3e0ea;
        --success: #27ae60;
        --failure: #c0392b;
        --partial-success: #f39c12;
        --partial-failure: #7f8c8d;
        --warning: #f1c40f;
        --shadow-light: rgba(44, 62, 80, 0.08);
        --shadow-medium: rgba(44, 62, 80, 0.12);
        --timer-warning: #f39c12;
        --timer-danger: #e74c3c;
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body { /* Moved font-family here for global application */
            font-family: 'League Spartan', 'Inter', system-ui, sans-serif;
            font-weight: 400;
            line-height: 1.6;
            background-color: var(--bg-primary); /* Ensures body bg is set */
            color: var(--text-primary); /* Ensures default text color */
            min-height: 100vh;
        }
        .dice-roller-app { /* Removed font properties, now on body */
            /* background-color: var(--bg-primary); /* Already on body */
            /* color: var(--text-primary); /* Already on body */
            /* min-height: 100vh; /* Already on body */
        }
        .app-title-header { text-align: center; padding: 20px 0; margin-bottom: 20px; }
        .app-title-header h1 { font-size: 2.8rem; font-weight: 800; color: var(--accent); letter-spacing: 1px; text-shadow: 1px 1px 0px var(--bg-tertiary); }
        .main-layout-container { display: grid; grid-template-columns: 280px 1fr; gap: 30px; max-width: 900px; margin: 0 auto; padding: 0 20px 30px 20px; }
        .left-column { padding: 20px; background-color: var(--bg-secondary); border-radius: 12px; box-shadow: 0 4px 12px var(--shadow-light); align-self: start; }
        .right-column { /* No specific styling */ }

        header.controls-header { 
            display: flex; 
            justify-content: flex-end; 
            align-items: center; 
            margin-bottom: 25px; 
            padding-bottom: 15px; 
            border-bottom: 2px solid var(--accent); 
        }
        .difficulty-control { 
            display: flex; /* Use flex to align label and buttons */
            align-items: center; 
            gap: 10px; /* Space between "DIFFICULTY:" and the buttons/value */
            background-color: var(--bg-secondary);
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            box-shadow: 0 1px 3px var(--shadow-light);
        }
        .difficulty-control .difficulty-label { /* New class for the "DIFFICULTY:" text */
            color: var(--text-secondary); 
            font-weight: 600; 
            font-size: 0.9rem; 
        }
        .difficulty-buttons-group { /* Wrapper for buttons and display */
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #difficultyDisplay {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--accent);
            padding: 0 8px; /* Space around the number */
            min-width: 20px; /* Ensure some space for the number */
            text-align: center;
        }
        .difficulty-buttons-group button { 
            width: 30px; height: 30px; 
            border: 1px solid var(--border); 
            border-radius: 8px; 
            background-color: var(--bg-tertiary); /* Slightly different from overall bg */
            color: var(--text-primary); 
            font-size: 1.2rem; font-weight: bold;
            cursor: pointer; 
            transition: all 0.2s;
            line-height: 1; /* For better vertical alignment of +/- */
        }
        .difficulty-buttons-group button:hover { background-color: var(--accent); color: white; transform: translateY(-1px); }
        .difficulty-buttons-group button:active { transform: translateY(0); }

        /* Tension Timers Section */
        .tension-timers-section {
            margin-bottom: 25px;
            padding: 18px;
            background-color: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-light);
        }

        .timer-controls-row {
            display: flex;
            gap: 20px;
            justify-content: space-between;
        }

        .timer-control-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .timer-label {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
        }

        .timer-display {
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--accent);
            padding: 8px 16px;
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            border: 2px solid var(--border);
            min-width: 80px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .timer-display.warning {
            color: var(--timer-warning);
            border-color: var(--timer-warning);
            background-color: rgba(243, 156, 18, 0.1);
        }

        .timer-display.danger {
            color: var(--timer-danger);
            border-color: var(--timer-danger);
            background-color: rgba(231, 76, 60, 0.1);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .timer-buttons {
            display: flex;
            gap: 6px;
        }

        .timer-btn {
            padding: 6px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-btn:hover {
            background-color: var(--accent);
            color: white;
            transform: translateY(-1px);
        }

        .timer-btn:active {
            transform: translateY(0);
        }

        .countdown-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .countdown-buttons-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .countdown-display {
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--accent);
            padding: 8px 16px;
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            border: 2px solid var(--border);
            min-width: 60px;
            text-align: center;
        }

        .countdown-buttons-group button {
            width: 30px;
            height: 30px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            line-height: 1;
        }

        .countdown-buttons-group button:hover {
            background-color: var(--accent);
            color: white;
            transform: translateY(-1px);
        }

        .countdown-buttons-group button:active {
            transform: translateY(0);
        }

        /* ... (rest of your existing CSS, unchanged) ... */
        .right-column h2 { font-size: 1.5rem; color: var(--accent); margin-bottom: 18px; padding-bottom: 10px; font-weight: 600; border-bottom: 1px solid var(--border); }
        .dice-pool-display { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 25px; padding: 18px; background-color: var(--bg-secondary); border-radius: 12px; min-height: 74px; box-shadow: 0 4px 12px var(--shadow-light); align-items: center; justify-content: center; }
        .dice-slot { width: 56px; height: 56px; border-radius: 10px; display: flex; align-items: center; justify-content: center; position: relative; background-color: var(--bg-tertiary); overflow: hidden; transition: transform 0.2s ease-out; }
        .dice-slot:hover { transform: scale(1.05); }
        .dice-slot.empty { border: 2.5px dashed rgba(41, 128, 185, 0.5); background-color: transparent; }
        .dice-slot.filled, .dice-slot.extra, .dice-slot.special-move-covered { border-width: 2.5px; border-style: solid; box-shadow: 0 2px 5px var(--shadow-light); }
        .dice-slot.filled { border-color: var(--accent); }
        .dice-slot.extra { border-color: var(--accent-secondary); }
        .dice-slot.special-move-covered { border-color: var(--accent-secondary); padding: 0; }
        img.player-cover-image { width: 100%; height: 100%; object-fit: cover; border-radius: 8px; display: block; }
        div.player-cover-image.generic-cover { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: var(--bg-tertiary); font-size: 2rem; color: var(--accent-secondary); border-radius: 8px; }
        .die-face { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 2rem; font-weight: bold; color: white; border-radius: 8px; text-shadow: 1px 1px 3px rgba(0,0,0,0.25); box-shadow: inset 0 0 5px rgba(0,0,0,0.1); }
        .die-face.placeholder, .die-face.filled-placeholder, .die-face.waiting { color: var(--text-secondary); background-color: transparent; font-size: 2.2rem; box-shadow: none; text-shadow: none; }
        .die-face.success { background-color: var(--success); }
        .die-face.failure { background-color: var(--failure); }
        .die-face.partial-success { background-color: var(--partial-success); }
        .die-face.partial-failure { background-color: var(--partial-failure); }
        .die-face.pushed-luck-die { background-color: var(--warning); color: var(--text-primary); border: 2px dashed var(--text-primary); }
        .die-face.animating { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 0%,100%{transform:translateX(0) rotate(0)}20%{transform:translateX(-4px) rotate(-3deg)}40%{transform:translateX(4px) rotate(3deg)}60%{transform:translateX(-3px) rotate(-2deg)}80%{transform:translateX(3px) rotate(2deg)} }
        .player-indicator { position: absolute; bottom: -6px; right: -6px; width: 26px; height: 26px; border-radius: 13px; overflow: hidden; border: 2px solid white; box-shadow: 0 1px 4px var(--shadow-medium); background-color: var(--text-secondary); }
        .player-indicator.generic { display:flex; align-items:center; justify-content:center; color: white; font-size: 0.9rem; font-weight: bold; } 
        .player-indicator img { width: 100%; height: 100%; object-fit: cover; }
        .status { padding: 14px 18px; background-color: var(--bg-secondary); border-radius: 10px; margin-bottom: 20px; text-align: center; color: var(--text-secondary); font-weight: 500; font-size: 1.05rem; box-shadow: 0 2px 8px var(--shadow-light); border-left: 4px solid var(--accent); }
        .players-section h2 { font-size: 1.5rem; color: var(--accent); margin-bottom: 18px; padding-bottom: 10px; font-weight: 600; border-bottom: 1px solid var(--border); text-align: center; }
        .player-list { display: flex; flex-direction: column; gap: 15px; align-items: stretch; }
        .player-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 10px; background-color: var(--bg-primary); box-shadow: 0 2px 6px var(--shadow-light); transition: all 0.2s ease-out; }
        .player-item:hover { transform: translateY(-2px); box-shadow: 0 4px 10px var(--shadow-medium); }
        .player-info { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
        .player-avatar-container { position: relative; width: 48px; height: 48px; border-radius: 50%; overflow: hidden; border: 2.5px solid var(--accent); display: flex; align-items: center; justify-content: center; background-color: var(--bg-tertiary); flex-shrink: 0; }
        .player-avatar-img { width: 100%; height: 100%; object-fit: cover; }
        .player-initial-avatar { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: var(--accent); color: white; font-size: 1.6rem; font-weight: bold; font-family: 'League Spartan', system-ui, sans-serif; }
        .player-name-label { font-size: 0.9rem; color: var(--text-primary); font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; }
        .player-action-icons { display: flex; gap: 8px; }
        .player-action-btn { background: var(--bg-secondary); border: 1px solid var(--border); color: var(--text-secondary); border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.2rem; transition: all 0.2s ease-out; box-shadow: 0 1px 2px var(--shadow-light); }
        .player-action-btn:hover:not(:disabled) { background-color: var(--accent); color: white; transform: scale(1.05); box-shadow: 0 2px 4px var(--shadow-medium); }
        .player-action-btn:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; background-color: var(--bg-tertiary); color: #a0a0a0; }
        .player-action-btn:last-child:hover:not(:disabled) { background-color: var(--accent-secondary); } 
        .add-player-button { width: 100%; padding: 10px; margin-top: 20px; border-radius: 8px; border: 2.5px dashed var(--border); background-color: transparent; color: var(--text-secondary); font-size: 1.2rem; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease-out; }
        .add-player-button:hover { color: var(--accent); border-color: var(--accent); background-color: var(--bg-tertiary); }
        .no-players-text { font-size: 0.95rem; color: var(--text-secondary); margin-top: 15px; text-align: center; }
        .actions-group { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .actions-group button { padding: 14px 18px; border: none; border-radius: 10px; font-weight: 600; font-size: 1rem; cursor: pointer; transition: all 0.2s ease-out; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 2px 5px var(--shadow-light); }
        .actions-group button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px var(--shadow-medium); }
        .actions-group button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 1px 3px var(--shadow-light); }
        .actions-group button:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none; }
        .btn-roll { font-size: 1.15rem; padding: 16px; }
        .btn-roll.reset-mode { background-color: var(--failure); color: white; }
        .btn-roll.roll-mode { background: linear-gradient(145deg, var(--success), #239b56); color: white; }
        .special-action-buttons-container { display: flex; justify-content: center; gap: 12px; margin-bottom: 25px; min-height: 44px; }
        .special-action-buttons-container button { padding: 10px 18px; border: none; border-radius: 8px; font-weight: 600; font-size: 0.9rem; cursor: pointer; background-color: var(--warning); color: var(--text-primary); box-shadow: 0 2px 5px var(--shadow-light); transition: all 0.2s ease-out; }
        .special-action-buttons-container button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px var(--shadow-medium); filter: brightness(1.05); }
        .special-action-buttons-container button:disabled { opacity: 0.5; background-color: var(--text-secondary); cursor: not-allowed; box-shadow: none; }
        .modal { position: fixed; top:0; left:0; right:0; bottom:0; background-color:rgba(20,30,40,0.6); display:flex; align-items:center; justify-content:center; z-index:1000; padding:20px; backdrop-filter:blur(3px); }
        .modal-content { background-color:var(--bg-secondary); padding:30px 35px; border-radius:16px; width:100%; max-width:480px; box-shadow:0 8px 25px rgba(44,62,80,0.2); }
        .modal-content h2 { text-align:center; margin-top:0; margin-bottom:25px; color:var(--accent); font-size:1.6rem; }
        .form-group { margin-bottom:22px; }
        .form-group label { display:block; margin-bottom:8px; font-weight:500; color:var(--text-secondary); font-size:0.9rem; }
        .form-group input[type="text"], .form-group input[type="file"] { width:100%; padding:12px 15px; border-radius:8px; border:1px solid var(--border); background-color:var(--bg-primary); color:var(--text-primary); font-size:1rem; transition:border-color .2s,box-shadow .2s; }
        .form-group input[type="text"]:focus, .form-group input[type="file"]:focus { outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(41,128,185,0.2); }
        .form-group input[type="file"] { padding:10px 15px; }
        .image-preview { margin-top:15px; width:100px; height:100px; border-radius:50%; overflow:hidden; border:3px solid var(--border); box-shadow:0 2px 4px var(--shadow-light); }
        .image-preview img { width:100%; height:100%; object-fit:cover; }
        .modal-actions { display:flex; justify-content:flex-end; gap:12px; margin-top:30px; }
        .modal-actions button { padding:10px 22px; border:none; border-radius:8px; font-weight:600; font-size:0.95rem; cursor:pointer; transition:all .2s ease-out; }
        .modal-actions button:first-child { background-color:transparent; color:var(--text-secondary); border:1px solid var(--border); }
        .modal-actions button:first-child:hover { background-color:var(--bg-tertiary); }
        .modal-actions button:last-child { background-color:var(--accent); color:white; box-shadow:0 2px 5px var(--shadow-light); }
        .modal-actions button:last-child:hover { background-color:#2471a3; box-shadow:0 3px 7px var(--shadow-medium); }
        .modal-actions button:disabled { opacity:.5; cursor:not-allowed; box-shadow:none!important; }
    </style>
</head>
<body>
  <div class="dice-roller-app">
    <div class="app-title-header">
      <h1>DICE ROLLER</h1>
    </div>

    <div class="main-layout-container">
      <div class="left-column players-section">
        <h2>Players</h2>
        <div id="playerList" class="player-list">
          <!-- Player items will be rendered here by JS -->
        </div>
        <button id="openAddPlayerModalBtn" class="add-player-button" title="Add New Player">
          + Add Player
        </button>
        <p id="noPlayersText" class="no-players-text" style="display: none;">No players yet. Click '+' to add.</p>
      </div>

      <div class="right-column">
        <header class="controls-header">
          <div class="difficulty-control">
            <span class="difficulty-label">DIFFICULTY:</span>
            <div class="difficulty-buttons-group">
              <button id="decreaseDifficultyBtn">-</button>
              <span id="difficultyDisplay">2</span>
              <button id="increaseDifficultyBtn">+</button>
            </div>
          </div>
        </header>

        <div id="dicePoolDisplay" class="dice-pool-display">
          <!-- Dice slots will be rendered here by JS -->
        </div>

        <!-- Tension Timers Section -->
        <div class="tension-timers-section">
          <div class="timer-controls-row">
            <!-- Tension Timer (Strategy Timer) -->
            <div class="timer-control-group">
              <div class="timer-label">TENSION TIMER</div>
              <div class="timer-display" id="tensionTimerDisplay">16s</div>
              <div class="timer-buttons">
                <button id="startTensionTimerBtn" class="timer-btn">START</button>
                <button id="pauseTensionTimerBtn" class="timer-btn" style="display: none;">PAUSE</button>
                <button id="resetTensionTimerBtn" class="timer-btn">RESET</button>
              </div>
            </div>

            <!-- Countdown Clock (Action Counter) -->
            <div class="timer-control-group">
              <div class="timer-label">TURNS LEFT</div>
              <div class="countdown-control">
                <div class="countdown-buttons-group">
                  <button id="decreaseCountdownBtn">-</button>
                  <span id="countdownDisplay" class="countdown-display">3</span>
                  <button id="increaseCountdownBtn">+</button>
                </div>
              </div>
              <button id="resetCountdownBtn" class="timer-btn">RESET</button>
            </div>
          </div>
        </div>

        <div id="statusMessage" class="status">Ready to roll!</div>

        <div class="actions-group">
          <button id="rollDiceBtn" class="btn-roll roll-mode">Roll Dice</button>
          <div id="specialActionButtonsContainer" class="special-action-buttons-container">
            <button id="pushLuckBtn" style="display:none;">Push Your Luck</button>
            <button id="payPriceBtn" style="display:none;">Pay Price & Redo Roll</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Add Player Modal -->
    <div id="addPlayerModal" class="modal" style="display: none;">
      <div class="modal-content">
        <h2>Add New Player</h2>
        <div class="form-group">
          <label for="playerNameInput">Player Name</label>
          <input id="playerNameInput" type="text" />
        </div>
        <div class="form-group">
          <label for="playerImageInput">Profile Image (Optional)</label>
          <input id="playerImageInput" type="file" accept="image/*" />
          <div id="imagePreviewContainer" class="image-preview" style="display:none;">
            <img id="imagePreview" src="#" alt="Preview" />
          </div>
        </div>
        <div class="modal-actions">
          <button id="cancelAddPlayerBtn">Cancel</button>
          <button id="confirmAddPlayerBtn">Add Player</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- GLOBAL STATE & CONFIG ---
    let difficulty = 2;
    let expertise = 0; // How many dice are in the pool
    let specialMoves = 0; // How many special moves are committed
    let rolls = []; // Stores the results of dice rolls: [5, 2, 6]
    let outcomeText = "";
    let isRolling = false; // True if dice animation is in progress
    let hasRolledThisTurn = false; // True if a roll (or special move resolution) has completed
    let canPushLuck = false; // True if a 6 was rolled and player can push luck
    let canPayPrice = false; // True if a 1 was rolled and player can pay price
    let pushedLuckDieRoll = null; // Stores the result of the "push your luck" die
    let isRedoingRollAfterPrice = false; // True if player is redoing a roll after paying price
    let indexOfRollToRedo = -1; // Index of the die in 'rolls' array to be re-rolled

    let players = []; // Array of player objects: { id, name, image, contributedDice, contributedSpecialMoves, color }
    let diceContributions = []; // Array of player IDs who contributed dice, in order of contribution
    let specialMoveContributions = []; // Array of player IDs who contributed special moves, in order

    let uploadedImage = null; // Temp store for uploaded player image data URL

    // Animation sequence state
    let currentRollIndex = null; // Index of the die currently being animated/rolled
    let currentAnimatedValue = null; // The value shown during animation
    let sequenceChainTimeoutId = null; // Timeout ID for managing sequential die rolls
    let currentSequenceTotalDice = 0; // Total dice in the current rolling sequence

    // Player Color Generation
    let nextPlayerHue = 0;
    const HUE_INCREMENT = 37; 
    const SATURATION = 70; // %
    const LIGHTNESS = 55; // %

    // Tension Timer state
    let tensionTimerInterval = null;
    let isTensionTimerRunning = false;
    let tensionTimerStartTime = 0; 
    let tensionTimerPausedTime = 0; 
    let tensionTimerSeconds; 

    // Countdown Clock state
    let countdownClock = 3; 

    // Animation Constants
    const SINGLE_DIE_ANIMATION_FRAMES = 12; 
    const SINGLE_DIE_ANIMATION_INTERVAL = 60; 
    const SINGLE_DIE_POST_ANIMATION_PAUSE = 350; 
    const BASE_DELAY_AFTER_DIE_FINISHES = 150; 
    const DELAY_INCREMENT_PER_DIE = 75; 

    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENT GRABBERS & CONSTANTS ---
        const dicePoolDisplayEl = document.getElementById('dicePoolDisplay');
        const playerListEl = document.getElementById('playerList');
        const noPlayersTextEl = document.getElementById('noPlayersText');
        const statusMessageEl = document.getElementById('statusMessage');
        const rollDiceBtn = document.getElementById('rollDiceBtn');
        const pushLuckBtn = document.getElementById('pushLuckBtn');
        const payPriceBtn = document.getElementById('payPriceBtn');
        const openAddPlayerModalBtn = document.getElementById('openAddPlayerModalBtn');

        // Difficulty controls
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const decreaseDifficultyBtn = document.getElementById('decreaseDifficultyBtn');
        const increaseDifficultyBtn = document.getElementById('increaseDifficultyBtn');

        // Tension Timer elements
        const tensionTimerDisplay = document.getElementById('tensionTimerDisplay');
        const startTensionTimerBtn = document.getElementById('startTensionTimerBtn');
        const pauseTensionTimerBtn = document.getElementById('pauseTensionTimerBtn');
        const resetTensionTimerBtn = document.getElementById('resetTensionTimerBtn');

        // Countdown Clock elements (from provided snippet)
        const countdownDisplay = document.getElementById('countdownDisplay');
        const decreaseCountdownBtn = document.getElementById('decreaseCountdownBtn');
        const increaseCountdownBtn = document.getElementById('increaseCountdownBtn');
        const resetCountdownBtn = document.getElementById('resetCountdownBtn');

        // Add Player Modal elements (from provided snippet)
        const addPlayerModalEl = document.getElementById('addPlayerModal');
        const playerNameInput = document.getElementById('playerNameInput');
        const playerImageInput = document.getElementById('playerImageInput');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreviewEl = document.getElementById('imagePreview');
        const cancelAddPlayerBtn = document.getElementById('cancelAddPlayerBtn');
        const confirmAddPlayerBtn = document.getElementById('confirmAddPlayerBtn');

        // Icons (from provided snippet)
        const DICE_ICON = 'ðŸŽ²';
        const STAR_ICON = 'âœ¨';
        const USER_ICON = 'ðŸ‘¤';


        // --- CORE LOGIC & FUNCTIONS ---
        function generatePlayerColor() {
            const hue = nextPlayerHue;
            nextPlayerHue = (nextPlayerHue + HUE_INCREMENT) % 360;
            return `hsl(${hue}, ${SATURATION}%, ${LIGHTNESS}%)`;
        }

        // Timer functions
        function calculateTensionTimerDuration() {
            return Math.max(1, difficulty) * 8; // 8 seconds per difficulty point
        }

        function updateTensionTimerDisplay() {
            const totalSeconds = calculateTensionTimerDuration();
            const minutes = Math.floor(tensionTimerSeconds / 60);
            const seconds = tensionTimerSeconds % 60;
            
            let displayText;
            if (minutes > 0) {
                displayText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                displayText = `${seconds}s`;
            }
            
            tensionTimerDisplay.textContent = displayText;
            
            // Color coding based on remaining time
            tensionTimerDisplay.classList.remove('warning', 'danger');
            const percentRemaining = tensionTimerSeconds / totalSeconds;
            
            if (tensionTimerSeconds <= 0 && totalSeconds > 0) { // Ensure totalSeconds is not zero to avoid NaN with 0/0
                 tensionTimerDisplay.classList.add('danger');
            } else if (percentRemaining <= 0.25) {
                tensionTimerDisplay.classList.add('danger');
            } else if (percentRemaining <= 0.5) {
                tensionTimerDisplay.classList.add('warning');
            }
        }

        function startTensionTimer() {
            if (isTensionTimerRunning) return;
            
            isTensionTimerRunning = true;
            tensionTimerStartTime = Date.now() - tensionTimerPausedTime;
            
            tensionTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - tensionTimerStartTime) / 1000);
                const totalSeconds = calculateTensionTimerDuration();
                tensionTimerSeconds = Math.max(0, totalSeconds - elapsed);
                
                updateTensionTimerDisplay();
                
                if (tensionTimerSeconds <= 0) {
                    // Timer expired - auto-fail
                    pauseTensionTimer();
                    outcomeText = "Time's up! Auto-fail due to tension timer expiring.";
                    hasRolledThisTurn = true; // Mark turn as 'rolled' for reset purposes
                    isRolling = false; // Ensure rolling state is false
                    // Potentially trigger other game logic for auto-fail here
                    fullUIUpdate(); // Update UI to reflect timer expiry and message
                }
            }, 100); // Check more frequently for smoother countdown
            
            startTensionTimerBtn.style.display = 'none';
            pauseTensionTimerBtn.style.display = 'inline-block';
        }

        function pauseTensionTimer() {
            if (!isTensionTimerRunning) return;
            
            isTensionTimerRunning = false;
            clearInterval(tensionTimerInterval);
            tensionTimerPausedTime = Date.now() - tensionTimerStartTime;
            
            startTensionTimerBtn.style.display = 'inline-block';
            pauseTensionTimerBtn.style.display = 'none';
        }

        function resetTensionTimer() {
            pauseTensionTimer();
            tensionTimerSeconds = calculateTensionTimerDuration();
            tensionTimerPausedTime = 0;
            updateTensionTimerDisplay();
        }

        function updateCountdownDisplay() {
            countdownDisplay.textContent = countdownClock;
        }

        function adjustCountdownClock(amount) {
            if (isRolling || hasRolledThisTurn) return; // Prevent adjustment during/after roll until reset
            countdownClock = Math.max(0, countdownClock + amount);
            updateCountdownDisplay();
        }

        function resetCountdownClock() {
            if (isRolling || hasRolledThisTurn) return; // Prevent reset during/after roll until main reset
            countdownClock = 3; // Or a configurable default
            updateCountdownDisplay();
        }

        const getNumSpecialMovesVisuallyCoveringSlots = () => Math.min(specialMoves, Math.max(0, difficulty));
        const getNumPrimarySlotsForExpertiseOrEmpty = () => {
            const coveredBySM = getNumSpecialMovesVisuallyCoveringSlots();
            return Math.max(0, difficulty - coveredBySM);
        };
        const getDicePool = () => expertise;

        function renderDicePool() {
            dicePoolDisplayEl.innerHTML = '';
            let expertiseDieRenderedCount = 0;
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();

            for (let i = 0; i < Math.max(0, difficulty); i++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('dice-slot');
                const isCoveredBySpecialMove = i >= Math.max(0, difficulty) - numSMCovers;

                if (isCoveredBySpecialMove) {
                    slotDiv.classList.add('special-move-covered');
                    const smContributionIndex = (numSMCovers - 1) - (i - (Math.max(0, difficulty) - numSMCovers));
                    const playerId = specialMoveContributions[smContributionIndex];
                    const player = playerId ? players.find(p => p.id === playerId) : null;

                    if (player && player.image) {
                        const img = document.createElement('img');
                        img.classList.add('player-cover-image');
                        img.src = player.image;
                        img.alt = `${player.name} covers this`;
                        img.title = `${player.name} covers this difficulty`;
                        slotDiv.appendChild(img);
                    } else if (player) {
                         const initialDiv = document.createElement('div');
                         initialDiv.classList.add('player-initial-avatar');
                         initialDiv.style.width = '100%';
                         initialDiv.style.height = '100%';
                         initialDiv.style.borderRadius = '8px';
                         initialDiv.textContent = player.name.charAt(0).toUpperCase();
                         initialDiv.title = `${player.name} covers this difficulty (Initial)`;
                         initialDiv.style.backgroundColor = player.color;
                         slotDiv.appendChild(initialDiv);
                    } else {
                        const genericCoverDiv = document.createElement('div');
                        genericCoverDiv.classList.add('player-cover-image', 'generic-cover');
                        genericCoverDiv.innerHTML = STAR_ICON;
                        genericCoverDiv.title = "Special Move covers this";
                        slotDiv.appendChild(genericCoverDiv);
                    }
                } else {
                    if (expertiseDieRenderedCount < expertise) {
                        slotDiv.classList.add('filled');
                        const currentExpertiseDieOriginalIndex = expertiseDieRenderedCount;
                        const playerIdForExpertise = diceContributions[currentExpertiseDieOriginalIndex];
                        const playerForExpertise = playerIdForExpertise ? players.find(p => p.id === playerIdForExpertise) : null;

                        const dieFaceDiv = document.createElement('div');
                        dieFaceDiv.classList.add('die-face');
                        let content = DICE_ICON;
                        dieFaceDiv.classList.add('placeholder');

                        if ((isRolling || isRedoingRollAfterPrice) && currentExpertiseDieOriginalIndex === currentRollIndex && currentAnimatedValue !== null) {
                            content = currentAnimatedValue;
                            dieFaceDiv.classList.remove('placeholder', 'waiting', 'filled-placeholder');
                            if (currentAnimatedValue === 6) dieFaceDiv.classList.add('success', 'animating');
                            else if (currentAnimatedValue === 1) dieFaceDiv.classList.add('failure', 'animating');
                            else if (currentAnimatedValue >= 4) dieFaceDiv.classList.add('partial-success', 'animating');
                            else dieFaceDiv.classList.add('partial-failure', 'animating');
                        } else if (rolls[currentExpertiseDieOriginalIndex] !== undefined) {
                            content = rolls[currentExpertiseDieOriginalIndex];
                            dieFaceDiv.classList.remove('placeholder', 'waiting', 'filled-placeholder');
                            if (rolls[currentExpertiseDieOriginalIndex] === 6) dieFaceDiv.classList.add('success');
                            else if (rolls[currentExpertiseDieOriginalIndex] === 1) dieFaceDiv.classList.add('failure');
                            else if (rolls[currentExpertiseDieOriginalIndex] >= 4) dieFaceDiv.classList.add('partial-success');
                            else dieFaceDiv.classList.add('partial-failure');
                        } else if (isRolling || isRedoingRollAfterPrice) {
                            dieFaceDiv.classList.add("waiting");
                        } else {
                            dieFaceDiv.classList.add("filled-placeholder");
                        }
                        dieFaceDiv.innerHTML = content;
                        slotDiv.appendChild(dieFaceDiv);

                        if (playerForExpertise) {
                            const indicator = document.createElement('div');
                            indicator.classList.add('player-indicator');
                            indicator.title = `Expertise from ${playerForExpertise.name}`;
                            if (playerForExpertise.image) {
                                const imgPlayerIndicator = document.createElement('img');
                                imgPlayerIndicator.src = playerForExpertise.image;
                                imgPlayerIndicator.alt = playerForExpertise.name;
                                indicator.appendChild(imgPlayerIndicator);
                            } else {
                                indicator.classList.add('generic');
                                indicator.textContent = playerForExpertise.name.charAt(0).toUpperCase();
                                indicator.style.backgroundColor = playerForExpertise.color;
                            }
                            slotDiv.appendChild(indicator);
                        }
                        expertiseDieRenderedCount++;
                    } else {
                        slotDiv.classList.add('empty');
                    }
                }
                dicePoolDisplayEl.appendChild(slotDiv);
            }

            for (let k = expertiseDieRenderedCount; k < expertise; k++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('dice-slot', 'extra');
                const currentExpertiseDieOriginalIndex = k;
                const playerIdForExpertise = diceContributions[currentExpertiseDieOriginalIndex];
                const playerForExpertise = playerIdForExpertise ? players.find(p => p.id === playerIdForExpertise) : null;

                const dieFaceDiv = document.createElement('div');
                dieFaceDiv.classList.add('die-face');
                let content = DICE_ICON;
                dieFaceDiv.classList.add('placeholder');

                if ((isRolling || isRedoingRollAfterPrice) && currentExpertiseDieOriginalIndex === currentRollIndex && currentAnimatedValue !== null) {
                    content = currentAnimatedValue;
                    dieFaceDiv.classList.remove('placeholder', 'waiting', 'filled-placeholder');
                    if (currentAnimatedValue === 6) dieFaceDiv.classList.add('success', 'animating');
                    else if (currentAnimatedValue === 1) dieFaceDiv.classList.add('failure', 'animating');
                    else if (currentAnimatedValue >= 4) dieFaceDiv.classList.add('partial-success', 'animating');
                    else dieFaceDiv.classList.add('partial-failure', 'animating');
                } else if (rolls[currentExpertiseDieOriginalIndex] !== undefined) {
                    content = rolls[currentExpertiseDieOriginalIndex];
                    dieFaceDiv.classList.remove('placeholder', 'waiting', 'filled-placeholder');
                    if (rolls[currentExpertiseDieOriginalIndex] === 6) dieFaceDiv.classList.add('success');
                    else if (rolls[currentExpertiseDieOriginalIndex] === 1) dieFaceDiv.classList.add('failure');
                    else if (rolls[currentExpertiseDieOriginalIndex] >= 4) dieFaceDiv.classList.add('partial-success');
                    else dieFaceDiv.classList.add('partial-failure');
                } else if (isRolling || isRedoingRollAfterPrice) {
                    dieFaceDiv.classList.add("waiting");
                } else {
                    dieFaceDiv.classList.add("filled-placeholder");
                }
                dieFaceDiv.innerHTML = content;
                slotDiv.appendChild(dieFaceDiv);

                if (playerForExpertise) {
                    const indicator = document.createElement('div');
                    indicator.classList.add('player-indicator');
                    indicator.title = `Expertise from ${playerForExpertise.name}`;
                     if (playerForExpertise.image) {
                        const imgPlayerIndicator = document.createElement('img');
                        imgPlayerIndicator.src = playerForExpertise.image;
                        imgPlayerIndicator.alt = playerForExpertise.name;
                        indicator.appendChild(imgPlayerIndicator);
                    } else {
                        indicator.classList.add('generic');
                        indicator.textContent = playerForExpertise.name.charAt(0).toUpperCase();
                        indicator.style.backgroundColor = playerForExpertise.color;
                    }
                    slotDiv.appendChild(indicator);
                }
                dicePoolDisplayEl.appendChild(slotDiv);
            }
            if (pushedLuckDieRoll !== null && !isRolling && !isRedoingRollAfterPrice) {
                const pushedDieSlot = document.createElement('div');
                pushedDieSlot.classList.add('dice-slot', 'filled');
                pushedDieSlot.style.borderColor = 'var(--warning)';
                const dieFaceDiv = document.createElement('div');
                dieFaceDiv.classList.add('die-face', 'pushed-luck-die');
                 if (pushedLuckDieRoll <= 3) dieFaceDiv.classList.add('failure'); else dieFaceDiv.classList.add('success');
                dieFaceDiv.textContent = pushedLuckDieRoll;
                pushedDieSlot.appendChild(dieFaceDiv);
                dicePoolDisplayEl.appendChild(pushedDieSlot);
            }
        }

        function renderPlayerList() {
            playerListEl.innerHTML = '';
            noPlayersTextEl.style.display = players.length === 0 ? 'block' : 'none';
            players.forEach(player => {
                const playerItemDiv = document.createElement('div');
                playerItemDiv.classList.add('player-item');
                const playerInfoDiv = document.createElement('div');
                playerInfoDiv.classList.add('player-info');
                const avatarContainer = document.createElement('div');
                avatarContainer.classList.add('player-avatar-container');
                if (player.image) {
                    const img = document.createElement('img');
                    img.src = player.image; img.alt = player.name; img.classList.add('player-avatar-img');
                    avatarContainer.appendChild(img);
                } else {
                    const initialDiv = document.createElement('div');
                    initialDiv.classList.add('player-initial-avatar');
                    initialDiv.textContent = player.name.charAt(0).toUpperCase();
                    initialDiv.style.backgroundColor = player.color;
                    avatarContainer.appendChild(initialDiv);
                }
                playerInfoDiv.appendChild(avatarContainer);
                const nameLabel = document.createElement('span');
                nameLabel.classList.add('player-name-label'); nameLabel.textContent = player.name;
                playerInfoDiv.appendChild(nameLabel);
                playerItemDiv.appendChild(playerInfoDiv);
                const actionIconsDiv = document.createElement('div');
                actionIconsDiv.classList.add('player-action-icons');
                const addExpertiseBtn = document.createElement('button');
                addExpertiseBtn.classList.add('player-action-btn'); addExpertiseBtn.innerHTML = DICE_ICON;
                addExpertiseBtn.title = `Add Expertise (${player.contributedDice}/3)`;
                addExpertiseBtn.disabled = player.contributedDice >= 3 || isRolling || canPushLuck || canPayPrice || isRedoingRollAfterPrice || hasRolledThisTurn;
                addExpertiseBtn.addEventListener('click', () => handlePlayerContributesExpertise(player.id));
                actionIconsDiv.appendChild(addExpertiseBtn);
                const addSpecialMoveBtn = document.createElement('button');
                addSpecialMoveBtn.classList.add('player-action-btn'); addSpecialMoveBtn.innerHTML = STAR_ICON;
                addSpecialMoveBtn.title = `Add Special Move`;
                const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();
                addSpecialMoveBtn.disabled = (difficulty > 0 && numSMCovers >= difficulty) || isRolling || canPushLuck || canPayPrice || isRedoingRollAfterPrice || hasRolledThisTurn;
                addSpecialMoveBtn.addEventListener('click', () => handlePlayerContributesSpecialMove(player.id));
                actionIconsDiv.appendChild(addSpecialMoveBtn);
                playerItemDiv.appendChild(actionIconsDiv);
                playerListEl.appendChild(playerItemDiv);
            });
        }

        function updateStatusMessage() {
            let msg = "Ready to roll!";
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();
            const numPrimarySlotsNeeded = getNumPrimarySlotsForExpertiseOrEmpty();
            const currentDicePool = getDicePool();

            if (isRolling && !isRedoingRollAfterPrice) {
                msg = "Rolling dice...";
            } else if (isRedoingRollAfterPrice) {
                msg = `Redo the roll of 1! (Price: ${outcomeText.split("Price Paid: ")[1]?.split(". Redo")[0] || 'Paid'})`;
            } else if (canPushLuck) {
                msg = `A 6! Push your luck? Or Reset.`;
            } else if (canPayPrice) {
                 msg = `A 1! Pay a price to redo this die and continue? Or Reset.`;
            } else if (outcomeText) {
                msg = outcomeText;
                 if (rolls.length > 0 && !isRolling && !isRedoingRollAfterPrice) {
                     msg += ` (XP: ${rolls.length * 10})`; // XP is awarded for each die rolled
                     if(pushedLuckDieRoll !== null) msg += ` (Pushed Luck Die: ${pushedLuckDieRoll})`;
                 }
            } else if (currentDicePool === 0 && difficulty > 0 && numSMCovers < difficulty) {
                msg = `Add expertise dice to attempt Difficulty ${difficulty}.`;
            } else if (expertise < numPrimarySlotsNeeded) {
                const needed = numPrimarySlotsNeeded - expertise;
                msg = `Need ${needed} more expertise ${needed === 1 ? 'die' : 'dice'} to cover Difficulty ${difficulty}.`;
            }
            statusMessageEl.textContent = msg;
        }

        function updateActionButtons() {
            const currentDicePool = getDicePool();
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();

            rollDiceBtn.classList.remove('roll-mode', 'reset-mode');

            if (hasRolledThisTurn && !isRolling && !isRedoingRollAfterPrice) {
                rollDiceBtn.textContent = "Reset & Prepare Next Roll";
                rollDiceBtn.disabled = false;
                rollDiceBtn.classList.add('reset-mode');
            } else if (isRedoingRollAfterPrice) {
                rollDiceBtn.textContent = "Redo Failed Roll";
                rollDiceBtn.disabled = isRolling; // Disable while re-roll animation is happening
                rollDiceBtn.classList.add('roll-mode');
            } else {
                rollDiceBtn.textContent = isRolling ? "Rolling..." : "Roll Dice";
                rollDiceBtn.disabled =
                    (difficulty > 0 && currentDicePool === 0 && numSMCovers < difficulty) || // Cannot roll if no dice and SM don't cover
                    isRolling || // Cannot roll if already rolling
                    expertise < getNumPrimarySlotsForExpertiseOrEmpty(); // Cannot roll if not enough expertise for non-SM slots
                rollDiceBtn.classList.add('roll-mode');
            }
            pushLuckBtn.style.display = canPushLuck ? 'inline-block' : 'none';
            payPriceBtn.style.display = canPayPrice ? 'inline-block' : 'none';
        }

        function updateDifficultyDisplay() {
            difficultyDisplay.textContent = difficulty;
            // Update tension timer duration when difficulty changes if timer not running
            if (!isTensionTimerRunning) {
                 tensionTimerSeconds = calculateTensionTimerDuration();
                 updateTensionTimerDisplay();
            }
        }

        function determineSingleDieOpportunity(die) {
             if (!canPushLuck && !canPayPrice) { // Only trigger if no opportunity is currently active
                if (die === 6) {
                    canPushLuck = true;
                } else if (die === 1) {
                    canPayPrice = true;
                }
             }
        }

        function finalizeOverallOutcome(diceArray) {
            outcomeText = ""; // Clear previous outcome
            // Stop tension timer when rolling is complete (if it was running)
            if (isTensionTimerRunning) {
                pauseTensionTimer();
            }
            
            // If an opportunity (push luck/pay price) is active, or redoing, or pushed luck already happened, don't finalize yet.
            if (canPushLuck || canPayPrice || isRedoingRollAfterPrice || pushedLuckDieRoll !== null) {
                 if(!canPushLuck && !canPayPrice && !isRedoingRollAfterPrice && pushedLuckDieRoll !== null) {
                     // This case is when pushedLuckDieRoll is set and no other opportunities exist, meaning outcome is already determined by push luck.
                     // The outcomeText for pushed luck is set in handlePushLuck.
                 } else {
                    return; // Don't determine final outcome yet.
                 }
            }

             // Case: Difficulty covered by special moves, no dice rolled.
             if (diceArray.length === 0 && getDicePool() === 0 && getNumSpecialMovesVisuallyCoveringSlots() >= difficulty && difficulty > 0) {
                 outcomeText = "Success! Difficulty covered by special moves, no roll needed.";
                 return;
             }

             // Case: No dice were available to roll, and SM didn't cover.
             if (diceArray.length === 0 && getDicePool() === 0 && !(getNumSpecialMovesVisuallyCoveringSlots() >= difficulty && difficulty > 0)) {
                if (hasRolledThisTurn) { //This implies an attempt was made but no dice were there.
                   outcomeText = "No dice rolled. Outcome determined by situation or requires dice."; return;
                } else { // No attempt made yet, so no outcome.
                    return;
                }
             }
             
             if (diceArray.length === 0) return; // Should not happen if previous checks are correct, but safety.

            const highest = Math.max(...diceArray);
            if (highest === 6 && !diceArray.includes(1)) outcomeText = "Success! The goal is achieved, cleanly.";
            else if (highest === 6 && diceArray.includes(1)) outcomeText = "Critical Success with a major complication (6 and 1)!";
            else if (highest === 1) outcomeText = "Failure! Face consequences, loss, or harm.";
            else if (highest <= 3) outcomeText = "Failure with a silver lining (2-3)"; // Highest is 2 or 3
            else outcomeText = "Success with a complication (4-5)"; // Highest is 4 or 5
            
            // Decrement countdown clock after each roll attempt (if it's positive)
            if (countdownClock > 0) {
                countdownClock--;
                updateCountdownDisplay();
            }
        }

        function fullUIUpdate() {
            updateDifficultyDisplay(); // This will also init tensionTimerSeconds if not running
            renderDicePool();
            renderPlayerList();
            updateActionButtons();
            updateStatusMessage();
            updateTensionTimerDisplay(); // Ensure it's up-to-date
            updateCountdownDisplay();
        }

        function handleImageUploadJS(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => { uploadedImage = e.target.result; imagePreviewEl.src = uploadedImage; imagePreviewContainer.style.display = 'block'; };
                reader.readAsDataURL(file);
            } else {
                uploadedImage = null;
                imagePreviewContainer.style.display = 'none';
                imagePreviewEl.src = "#";
            }
        }

        function addPlayerJS() {
            const name = playerNameInput.value.trim();
            if (name) {
                players.push({
                    id: Date.now(), name, image: uploadedImage,
                    contributedDice: 0, contributedSpecialMoves: 0,
                    color: generatePlayerColor()
                });
                playerNameInput.value = ''; playerImageInput.value = ''; uploadedImage = null;
                imagePreviewContainer.style.display = 'none'; imagePreviewEl.src = "#";
                addPlayerModalEl.style.display = 'none';
                fullUIUpdate();
            } else { alert("Player name is required."); }
        }

        function handlePlayerContributesExpertise(playerId) {
            if (hasRolledThisTurn || isRolling || canPushLuck || canPayPrice || isRedoingRollAfterPrice) return;
            const playerIndex = players.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;
            if (players[playerIndex].contributedDice < 3) {
                players[playerIndex].contributedDice += 1;
                diceContributions.push(playerId); expertise += 1;
                fullUIUpdate();
            } else { alert(`${players[playerIndex].name} has reached the maximum of 3 expertise contributions.`); }
        }

        function handlePlayerContributesSpecialMove(playerId) {
             if (hasRolledThisTurn || isRolling || canPushLuck || canPayPrice || isRedoingRollAfterPrice) return;
            const playerIndex = players.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();
            if (difficulty > 0 && numSMCovers >= difficulty) {
                alert("All difficulty slots are already covered by special moves."); return;
            }
            players[playerIndex].contributedSpecialMoves += 1;
            specialMoveContributions.push(playerId); specialMoves += 1;
            fullUIUpdate();
        }

        function clearAllContributionsAndStatsJS() {
            players.forEach(p => { p.contributedDice = 0; p.contributedSpecialMoves = 0; });
            diceContributions = []; specialMoveContributions = [];
            expertise = 0; specialMoves = 0;
            rolls = []; outcomeText = "";
            isRolling = false; hasRolledThisTurn = false;
            currentRollIndex = null; currentAnimatedValue = null;

            if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId);
            sequenceChainTimeoutId = null;

            canPushLuck = false; canPayPrice = false;
            pushedLuckDieRoll = null; isRedoingRollAfterPrice = false;
            indexOfRollToRedo = -1;
            currentSequenceTotalDice = 0;
            
            // Reset tension timer
            resetTensionTimer(); // This will also update its display.
            // Countdown clock is not reset here, it's a separate persistent counter.
            fullUIUpdate();
        }

        function handlePushLuck() {
            if (!canPushLuck) return;

            if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId); // Stop any pending next die roll
            sequenceChainTimeoutId = null;

            pushedLuckDieRoll = Math.floor(Math.random() * 6) + 1;
            canPushLuck = false; // Opportunity used
            if (pushedLuckDieRoll <= 3) {
                outcomeText = "Push Your Luck Failed! Original success potentially undone, complication added.";
            } else {
                outcomeText = "Push Your Luck Succeeded! Advantage pressed further.";
            }
            // Don't add to `rolls` array, it's a separate event modifying the outcome of the `rolls`.
            // If it was a 6 or 1, adjust countdown clock
            if (pushedLuckDieRoll === 6 && countdownClock < 99) { // Assuming 99 is max for countdown
                 countdownClock++;
                 outcomeText += " (+1 to Countdown Clock)";
            } else if (pushedLuckDieRoll === 1 && countdownClock > 0) {
                 countdownClock--;
                 outcomeText += " (-1 to Countdown Clock)";
            }


            isRolling = false; // Rolling sequence (if any) is definitely over or interrupted.
            hasRolledThisTurn = true; // The turn is now fully resolved.
            fullUIUpdate();
        }

         function handlePayPrice() {
            if (!canPayPrice) return;
            const pricePaidDescription = prompt("Describe the price you pay (e.g., lose supplies, take stress, alert enemies):");
            if (pricePaidDescription === null) return; // User cancelled
            if (pricePaidDescription.trim() === "") {
                alert("You must describe a price to pay.");
                return;
            }

            if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId); // Stop any pending next die roll
            sequenceChainTimeoutId = null;

            canPayPrice = false; // Opportunity used
            isRedoingRollAfterPrice = true;
            if(indexOfRollToRedo === -1) { // Should have been set by determineSingleDieOpportunity via processNextDieInSequence
                 alert("Error: Could not identify which roll to redo. Resetting.");
                 clearAllContributionsAndStatsJS();
                 return;
            }
            outcomeText = `Price Paid: ${pricePaidDescription}. Redo the roll of 1.`;
            pushedLuckDieRoll = null; // Clear any pushed luck attempt if one was pending (shouldn't happen)
            isRolling = false; // Not actively rolling the main sequence anymore
            // hasRolledThisTurn remains true or becomes true because an action is taken.
            // The actual "re-roll" will happen when user clicks "Roll Dice" button again (now in redo mode).
            fullUIUpdate();
        }

        function startRollingJS() {
            if (rollDiceBtn.classList.contains('reset-mode')) {
                clearAllContributionsAndStatsJS();
                return;
            }

            // Stop tension timer when roll button is pressed (if it was running)
            if (isTensionTimerRunning) {
                pauseTensionTimer();
            }

            if (isRedoingRollAfterPrice) {
                if (indexOfRollToRedo === -1) {
                    alert("Error: Cannot redo roll, index invalid.");
                    isRedoingRollAfterPrice = false; fullUIUpdate(); return;
                }
                isRolling = true; // Now we are actively rolling for the redo
                outcomeText = ""; // Clear the "Price Paid" message for the rolling phase
                currentAnimatedValue = null;
                currentRollIndex = indexOfRollToRedo; // Target the specific die
                renderDicePool(); // Show waiting state for the target die

                let animationCounter = 0;
                const animationIntervalId = setInterval(() => {
                    currentAnimatedValue = Math.floor(Math.random() * 6) + 1;
                    renderDicePool(); // Update with animation frame
                    animationCounter++;
                    if (animationCounter >= SINGLE_DIE_ANIMATION_FRAMES) {
                        clearInterval(animationIntervalId);
                        const newDieRoll = Math.floor(Math.random() * 6) + 1;
                        rolls[indexOfRollToRedo] = newDieRoll; // Update the specific roll
                        currentAnimatedValue = newDieRoll;
                        renderDicePool(); // Show final result of the re-rolled die

                        // Adjust countdown clock based on the re-rolled die
                        if (newDieRoll === 6 && countdownClock < 99) countdownClock++;
                        else if (newDieRoll === 1 && countdownClock > 0) countdownClock--;
                        // No updateCountdownDisplay() here, will be done in fullUIUpdate

                        const redoDisplayPauseTimeout = setTimeout(() => {
                            currentAnimatedValue = null; // Clear animation value
                            isRolling = false;
                            isRedoingRollAfterPrice = false; // Redo is complete

                            determineSingleDieOpportunity(newDieRoll); // Check if the new roll creates another opportunity

                            if (canPushLuck || canPayPrice) {
                                // New opportunity arose from the re-roll
                                hasRolledThisTurn = true; // The "turn" involving this die is complete for now
                                if(canPayPrice) indexOfRollToRedo = currentRollIndex; // Set for potential next redo
                                fullUIUpdate();
                            } else {
                                // No new opportunity, continue original sequence or finalize
                                const dieSlotThatWasRedone = indexOfRollToRedo;
                                indexOfRollToRedo = -1; // Clear redo index
                                outcomeText = ""; // Clear any intermediate messages

                                const nextDieInOriginalSequence = dieSlotThatWasRedone + 1;

                                if (nextDieInOriginalSequence < currentSequenceTotalDice) {
                                    // There were more dice in the original sequence
                                    isRolling = true; // Resume rolling sequence
                                    fullUIUpdate(); // Update status to "Rolling..."

                                    sequenceChainTimeoutId = setTimeout(() => {
                                        if(isRolling) { // Check if still in rolling state (e.g. user didn't reset)
                                            processNextDieInSequence(nextDieInOriginalSequence, currentSequenceTotalDice);
                                        }
                                    }, SINGLE_DIE_POST_ANIMATION_PAUSE / 2); // Shorter delay to resume
                                } else {
                                    // Re-rolled die was the last one in sequence
                                    finalizeOverallOutcome(rolls);
                                    hasRolledThisTurn = true;
                                    fullUIUpdate();
                                }
                            }
                        }, SINGLE_DIE_POST_ANIMATION_PAUSE);
                    }
                }, SINGLE_DIE_ANIMATION_INTERVAL);
                return;
            }

            const currentDicePool = getDicePool();
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();
             if (currentDicePool === 0) { // No expertise dice
                if (difficulty > 0 && numSMCovers >= difficulty) { // SM cover difficulty
                     outcomeText = "Success! Difficulty covered by special moves, no roll needed.";
                     finalizeOverallOutcome([]); // Pass empty array as no dice rolled
                     hasRolledThisTurn = true;
                } else if (difficulty > 0 && numSMCovers < difficulty) { // SM not enough, no dice
                    outcomeText = "Cannot roll: Need more expertise or special moves for this difficulty.";
                    hasRolledThisTurn = false; // No roll attempt made
                } else { // Difficulty is 0
                    outcomeText = "Difficulty is 0, automatic success assumed. No roll needed.";
                     finalizeOverallOutcome([]);
                     hasRolledThisTurn = true;
                }
                isRolling = false; fullUIUpdate(); return;
            }
            // Check if enough expertise dice for non-SM covered slots
            if (expertise < getNumPrimarySlotsForExpertiseOrEmpty()) {
                outcomeText = `Cannot roll: Need ${getNumPrimarySlotsForExpertiseOrEmpty() - expertise} more expertise.`;
                hasRolledThisTurn = false;
                isRolling = false; fullUIUpdate(); return;
            }


            rolls = []; // Reset rolls array
            for(let i=0; i < currentDicePool; ++i) rolls.push(undefined); // Initialize with placeholders

            outcomeText = ""; // Clear previous outcome
            canPushLuck = false; canPayPrice = false; pushedLuckDieRoll = null;
            if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId);
            sequenceChainTimeoutId = null;

            isRolling = true; hasRolledThisTurn = false; // Reset hasRolledThisTurn for the new roll sequence
            currentRollIndex = 0;
            currentAnimatedValue = null;
            currentSequenceTotalDice = currentDicePool; // Store how many dice are in this sequence

            fullUIUpdate(); // Update UI to "Rolling..."
            processNextDieInSequence(0, currentSequenceTotalDice);
        }

        function processNextDieInSequence(rollIdx, totalDiceInPool) {
            if (!isRolling) { // If isRolling was set to false (e.g. by reset or opportunity)
                if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId);
                sequenceChainTimeoutId = null;
                return;
            }
            if (canPushLuck || canPayPrice) { // An opportunity has arisen, pause sequence
                // UI update will handle displaying opportunity buttons
                isRolling = false; // Stop the automatic sequence
                hasRolledThisTurn = true; // Mark that a roll result leading to opportunity occurred
                fullUIUpdate();
                return;
            }

            currentRollIndex = rollIdx;
            currentAnimatedValue = null; // Reset for animation
            renderDicePool(); // Show "waiting" for the current die

            let animationCounter = 0;
            const animationIntervalId = setInterval(() => {
                if (!isRolling) { // Double check if rolling was aborted mid-animation
                    clearInterval(animationIntervalId);
                    return;
                }
                currentAnimatedValue = Math.floor(Math.random() * 6) + 1;
                renderDicePool(); // Update with animation frame
                animationCounter++;

                if (animationCounter >= SINGLE_DIE_ANIMATION_FRAMES) {
                    clearInterval(animationIntervalId);

                    const currentDieRoll = Math.floor(Math.random() * 6) + 1;
                    rolls[rollIdx] = currentDieRoll;
                    currentAnimatedValue = currentDieRoll;
                    renderDicePool(); // Show final result for this die

                    // Check for countdown clock adjustments based on die roll
                    if (currentDieRoll === 6 && countdownClock < 99) { // Assuming 99 max
                        countdownClock++;
                        // No updateCountdownDisplay() here, will be done by fullUIUpdate
                    } else if (currentDieRoll === 1 && countdownClock > 0) {
                        countdownClock--;
                        // No updateCountdownDisplay() here
                    }


                    const postAnimationPauseTimeout = setTimeout(() => {
                        if (!isRolling && !(canPushLuck || canPayPrice)) { // If aborted and no opportunity, just stop.
                             currentAnimatedValue = null; renderDicePool(); return;
                        }

                        currentAnimatedValue = null; // Clear animation value for next die
                        renderDicePool(); // Reflect cleared animation value

                        determineSingleDieOpportunity(currentDieRoll);

                        if (canPushLuck || canPayPrice) {
                            isRolling = false; // Stop sequence, player interaction needed
                            hasRolledThisTurn = true; // A result is available
                            if (canPayPrice) {
                                indexOfRollToRedo = rollIdx; // Store which die caused the 'pay price' option
                            }
                            fullUIUpdate(); // Show opportunity buttons
                            return;
                        }

                        const isLastDieInSequence = (rollIdx + 1) >= totalDiceInPool;

                        if (isLastDieInSequence) {
                            isRolling = false;
                            currentRollIndex = null; // No die is "current" anymore
                            finalizeOverallOutcome(rolls);
                            hasRolledThisTurn = true;
                            fullUIUpdate();
                        } else {
                            // Schedule next die roll in sequence
                            const delayForNextDie = BASE_DELAY_AFTER_DIE_FINISHES + (rollIdx * DELAY_INCREMENT_PER_DIE);
                            sequenceChainTimeoutId = setTimeout(() => {
                                if (isRolling) { // Check again, in case of user interruption
                                    processNextDieInSequence(rollIdx + 1, totalDiceInPool);
                                }
                            }, delayForNextDie);
                        }
                    }, SINGLE_DIE_POST_ANIMATION_PAUSE);
                }
            }, SINGLE_DIE_ANIMATION_INTERVAL);
        }

        // --- EVENT LISTENERS ---
        decreaseDifficultyBtn.addEventListener('click', () => { 
            if (!isRolling && !hasRolledThisTurn && !canPushLuck && !canPayPrice) { 
                difficulty = Math.max(0, difficulty - 1); 
                fullUIUpdate(); 
            }
        });
        increaseDifficultyBtn.addEventListener('click', () => { 
            if (!isRolling && !hasRolledThisTurn && !canPushLuck && !canPayPrice) { 
                difficulty += 1; 
                fullUIUpdate(); 
            }
        });

        // Timer event listeners
        startTensionTimerBtn.addEventListener('click', startTensionTimer);
        pauseTensionTimerBtn.addEventListener('click', pauseTensionTimer);
        resetTensionTimerBtn.addEventListener('click', resetTensionTimer);
        
        decreaseCountdownBtn.addEventListener('click', () => adjustCountdownClock(-1));
        increaseCountdownBtn.addEventListener('click', () => adjustCountdownClock(1));
        resetCountdownBtn.addEventListener('click', resetCountdownClock);

        openAddPlayerModalBtn.addEventListener('click', () => { addPlayerModalEl.style.display = 'flex'; });
        cancelAddPlayerBtn.addEventListener('click', () => {
            addPlayerModalEl.style.display = 'none'; playerNameInput.value = ''; playerImageInput.value = '';
            uploadedImage = null; imagePreviewContainer.style.display = 'none'; imagePreviewEl.src = '#';
        });
        confirmAddPlayerBtn.addEventListener('click', addPlayerJS);
        playerImageInput.addEventListener('change', handleImageUploadJS);
        rollDiceBtn.addEventListener('click', startRollingJS);
        pushLuckBtn.addEventListener('click', handlePushLuck);
        payPriceBtn.addEventListener('click', handlePayPrice);

        // Initial UI setup
        fullUIUpdate();
    });
  </script>
</body>
</html>
