<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice Roller with Tension Timers</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=League+Spartan:wght@400;500;600;700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
        --bg-primary: #f8fafc;
        --bg-secondary: #ffffff;
        --bg-tertiary: #e9eff3; 
        --text-primary: #2c3e50;
        --text-secondary: #526c84;
        --border-color: #dce4ec; /* Softer border */
        
        /* Countdown Clock - Normal State (Blue Ring, White Text) */
        --countdown-ring-normal-fill: #2980b9; 
        --countdown-text-normal-color: white;

        /* Tension Timer & Countdown Warning State (Orange/Yellowish) */
        --timer-gradient-warning-start: #fdd835; 
        --timer-gradient-warning-end: #f9a825;   
        --timer-text-warning-color: white; /* For contrast on orange gradient */
        
        /* Tension Timer & Countdown Danger State (Red) */
        --timer-gradient-danger-start: #ef5350; 
        --timer-gradient-danger-end: #d32f2f;    
        --timer-text-danger-color: white;

        /* Tension Timer Normal State (Blue Gradient) */
        --timer-gradient-normal-start: #6cb2e9; 
        --timer-gradient-normal-end: #2991de;   
        --timer-text-normal-color: white;

        --countdown-ring-track-color: #d0d9e0;

        --accent-secondary: #8e44ad;
        --success: #27ae60;
        --failure: #c0392b;
        --shadow-light: rgba(44, 62, 80, 0.08);
        --shadow-medium: rgba(44, 62, 80, 0.12);
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'League Spartan', 'Inter', system-ui, sans-serif;
            font-weight: 400;
            line-height: 1.6;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }
        .app-title-header { text-align: center; padding: 20px 0; margin-bottom: 20px; }
        .app-title-header h1 { font-size: 2.8rem; font-weight: 800; color: var(--countdown-ring-normal-fill); letter-spacing: 1px; text-shadow: 1px 1px 0px var(--bg-tertiary); }
        .main-layout-container { display: grid; grid-template-columns: 280px 1fr; gap: 30px; max-width: 900px; margin: 0 auto; padding: 0 20px 30px 20px; }
        .left-column { padding: 20px; background-color: var(--bg-secondary); border-radius: 12px; box-shadow: 0 4px 12px var(--shadow-light); align-self: start; }
        
        header.controls-header { display: flex; justify-content: flex-end; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid var(--countdown-ring-normal-fill); }
        .difficulty-control { display: flex; align-items: center; gap: 10px; background-color: var(--bg-secondary); padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border-color); box-shadow: 0 1px 3px var(--shadow-light); }
        .difficulty-control .difficulty-label { color: var(--text-secondary); font-weight: 600; font-size: 0.9rem; }
        .difficulty-buttons-group { display: flex; align-items: center; gap: 6px; }
        #difficultyDisplay { font-weight: bold; font-size: 1.1rem; color: var(--countdown-ring-normal-fill); padding: 0 8px; min-width: 20px; text-align: center; }
        .difficulty-buttons-group button { width: 30px; height: 30px; border: 1px solid var(--border-color); border-radius: 8px; background-color: var(--bg-tertiary); color: var(--text-primary); font-size: 1.2rem; font-weight: bold; cursor: pointer; transition: all 0.2s; line-height: 1; }
        .difficulty-buttons-group button:hover { background-color: var(--countdown-ring-normal-fill); color: white; transform: translateY(-1px); }
        .difficulty-buttons-group button:active { transform: translateY(0); }

        .tension-timers-section { margin-bottom: 25px; padding: 18px; background-color: var(--bg-secondary); border-radius: 12px; box-shadow: 0 4px 12px var(--shadow-light); }
        .timer-controls-row { display: flex; gap: 25px; justify-content: space-around; align-items: flex-start; }
        .timer-control-group { flex-basis: 45%; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .timer-label { font-weight: 600; font-size: 0.9rem; color: var(--text-secondary); letter-spacing: 0.5px; margin-bottom: 0px; text-transform: uppercase;}
        
        .visual-timer-display-area { display: flex; align-items: center; gap: 10px; width: 100%; justify-content: center; }
        
        /* Tension Timer with SVG Border */
        .visual-timer-container {
            position: relative; 
            display: flex; 
            align-items: center;
            justify-content: center;
            background-color: var(--bg-tertiary); /* Plain gray backdrop */
            border-radius: 10px; 
            width: 110px; 
            height: 60px;    
            overflow: visible; /* Allow SVG stroke to be outside if needed for thickness */
            border: 1px solid var(--border-color); /* Fallback border */
        }
        .timer-svg-border {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; /* So it doesn't interfere with text selection */
        }
        .timer-svg-border rect {
            width: calc(100% - 6px); /* Account for stroke width for inner feel */
            height: calc(100% - 6px);
            x: 3px; y: 3px;
            fill: transparent;
            stroke-width: 6px; /* Thickness of the gradient border */
            rx: 7px; /* Rounded corners for the SVG rect */
            stroke-dasharray: 1000; /* Large enough, will be set by JS */
            stroke-dashoffset: 0;  /* JS animates this */
            transition: stroke-dashoffset 0.15s linear, stroke 0.3s ease;
        }
        .timer-text-content {
            font-family: 'League Spartan', sans-serif;
            font-size: 2.6rem; 
            font-weight: 700; 
            z-index: 2;
            line-height: 1; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent; /* Text color is transparent, shows gradient bg */
            /* Gradient background will be set by JS */
        }

        /* Countdown Clock with SVG Ring */
        #countdownVisualContainer {
            /* Uses .visual-timer-container for base styling */
        }
        .countdown-pie-svg { /* Changed to countdown-ring-svg */
            width: 52px; 
            height: 52px;
            position: absolute; 
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(-90deg); 
            z-index: 1;
        }
        .countdown-ring-track, .countdown-ring-fill-segment { 
            fill: transparent;
            stroke-linecap: round; 
        }
        .countdown-ring-track {
            stroke: var(--countdown-ring-track-color); 
            stroke-width: 7; 
        }
        .countdown-ring-fill-segment {
            stroke: var(--countdown-ring-normal-fill); 
            stroke-width: 7; 
            transition: stroke-dashoffset 0.25s ease-in-out, stroke 0.25s ease-in-out;
        }
        .countdown-text-content { 
            font-family: 'League Spartan', sans-serif;
            font-size: 1.8rem; /* Adjusted for N/M format */
            font-weight: 700; 
            z-index: 2;
            line-height: 1; 
            color: var(--countdown-text-normal-color); /* Default text color */
        }
        
        .timer-buttons { display: flex; gap: 10px; margin-top: 8px; }
        .timer-btn { 
            padding: 7px 15px; border: 1px solid var(--border-color); border-radius: 8px; 
            background-color: var(--bg-tertiary); color: var(--text-primary); 
            font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.2s; 
            box-shadow: 0 1px 2px var(--shadow-light);
        }
        .timer-btn:hover { background-color: var(--countdown-ring-normal-fill); color: white; transform: translateY(-1px); box-shadow: 0 2px 4px var(--shadow-medium); }
        .timer-btn:active { transform: translateY(0); box-shadow: 0 1px 2px var(--shadow-light); }
        
        .countdown-buttons-group { display: flex; flex-direction: column; gap: 6px; }
        .countdown-buttons-group button { 
            width: 32px; height: 28px; border: 1px solid var(--border-color); 
            border-radius: 6px; background-color: var(--bg-tertiary); 
            color: var(--text-primary); font-size: 1.2rem; 
            font-weight: bold; cursor: pointer; transition: all 0.2s; line-height: 1; 
            box-shadow: 0 1px 1px var(--shadow-light);
        }
        .countdown-buttons-group button:hover { background-color: var(--countdown-ring-normal-fill); color: white; transform: translateY(-1px); }

        /* Fallback for non-gradient text or if needed */
        .timer-text-content.normal { color: var(--timer-text-normal-color); }
        .timer-text-content.warning { color: var(--timer-text-warning-color); }
        .timer-text-content.danger { color: var(--timer-text-danger-color); }


        .dice-pool-display { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 25px; padding: 18px; background-color: var(--bg-secondary); border-radius: 12px; min-height: 74px; box-shadow: 0 4px 12px var(--shadow-light); align-items: center; justify-content: center; }
        .dice-slot { width: 56px; height: 56px; border-radius: 10px; display: flex; align-items: center; justify-content: center; position: relative; background-color: var(--bg-tertiary); overflow: hidden; transition: transform 0.2s ease-out; }
        .dice-slot:hover { transform: scale(1.05); }
        .dice-slot.empty { border: 2.5px dashed rgba(41, 128, 185, 0.5); background-color: transparent; }
        .dice-slot.filled, .dice-slot.extra, .dice-slot.special-move-covered { border-width: 2.5px; border-style: solid; box-shadow: 0 2px 5px var(--shadow-light); }
        .dice-slot.filled { border-color: var(--countdown-ring-normal-fill); }
        .dice-slot.extra { border-color: var(--accent-secondary); }
        .dice-slot.special-move-covered { border-color: var(--accent-secondary); padding: 0; }
        img.player-cover-image { width: 100%; height: 100%; object-fit: cover; border-radius: 8px; display: block; }
        div.player-cover-image.generic-cover { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: var(--bg-tertiary); font-size: 2rem; color: var(--accent-secondary); border-radius: 8px; }
        .die-face { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 2rem; font-weight: bold; color: white; border-radius: 8px; text-shadow: 1px 1px 3px rgba(0,0,0,0.25); box-shadow: inset 0 0 5px rgba(0,0,0,0.1); }
        .die-face.placeholder, .die-face.filled-placeholder, .die-face.waiting { color: var(--text-secondary); background-color: transparent; font-size: 2.2rem; box-shadow: none; text-shadow: none; }
        .die-face.success { background-color: var(--success); }
        .die-face.failure { background-color: var(--failure); }
        .die-face.partial-success { background-color: var(--timer-gradient-warning-end); } /* Using timer warning color */
        .die-face.partial-failure { background-color: #7f8c8d; }
        .die-face.pushed-luck-die { background-color: #f1c40f; color: var(--text-primary); border: 2px dashed var(--text-primary); }
        .die-face.animating { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 0%,100%{transform:translateX(0) rotate(0)}20%{transform:translateX(-4px) rotate(-3deg)}40%{transform:translateX(4px) rotate(3deg)}60%{transform:translateX(-3px) rotate(-2deg)}80%{transform:translateX(3px) rotate(2deg)} }
        .player-indicator { position: absolute; bottom: -6px; right: -6px; width: 26px; height: 26px; border-radius: 13px; overflow: hidden; border: 2px solid white; box-shadow: 0 1px 4px var(--shadow-medium); background-color: var(--text-secondary); }
        .player-indicator.generic { display:flex; align-items:center; justify-content:center; color: white; font-size: 0.9rem; font-weight: bold; } 
        .player-indicator img { width: 100%; height: 100%; object-fit: cover; }
        .status { padding: 14px 18px; background-color: var(--bg-secondary); border-radius: 10px; margin-bottom: 20px; text-align: center; color: var(--text-secondary); font-weight: 500; font-size: 1.05rem; box-shadow: 0 2px 8px var(--shadow-light); border-left: 4px solid var(--countdown-ring-normal-fill); }
        .players-section h2 { font-size: 1.5rem; color: var(--countdown-ring-normal-fill); margin-bottom: 18px; padding-bottom: 10px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; }
        .player-list { display: flex; flex-direction: column; gap: 15px; align-items: stretch; }
        .player-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 10px; background-color: var(--bg-primary); box-shadow: 0 2px 6px var(--shadow-light); transition: all 0.2s ease-out; }
        .player-item:hover { transform: translateY(-2px); box-shadow: 0 4px 10px var(--shadow-medium); }
        .player-info { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
        .player-avatar-container { position: relative; width: 48px; height: 48px; border-radius: 50%; overflow: hidden; border: 2.5px solid var(--countdown-ring-normal-fill); display: flex; align-items: center; justify-content: center; background-color: var(--bg-tertiary); flex-shrink: 0; }
        .player-avatar-img { width: 100%; height: 100%; object-fit: cover; }
        .player-initial-avatar { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: var(--countdown-ring-normal-fill); color: white; font-size: 1.6rem; font-weight: bold; font-family: 'League Spartan', system-ui, sans-serif; }
        .player-name-label { font-size: 0.9rem; color: var(--text-primary); font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; }
        .player-action-icons { display: flex; gap: 8px; }
        .player-action-btn { background: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.2rem; transition: all 0.2s ease-out; box-shadow: 0 1px 2px var(--shadow-light); }
        .player-action-btn:hover:not(:disabled) { background-color: var(--countdown-ring-normal-fill); color: white; transform: scale(1.05); box-shadow: 0 2px 4px var(--shadow-medium); }
        .player-action-btn:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; background-color: var(--bg-tertiary); color: #a0a0a0; }
        .player-action-btn:last-child:hover:not(:disabled) { background-color: var(--accent-secondary); } 
        .add-player-button { width: 100%; padding: 10px; margin-top: 20px; border-radius: 8px; border: 2.5px dashed var(--border-color); background-color: transparent; color: var(--text-secondary); font-size: 1.2rem; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease-out; }
        .add-player-button:hover { color: var(--countdown-ring-normal-fill); border-color: var(--countdown-ring-normal-fill); background-color: var(--bg-tertiary); }
        .no-players-text { font-size: 0.95rem; color: var(--text-secondary); margin-top: 15px; text-align: center; }
        .actions-group { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .actions-group button { padding: 14px 18px; border: none; border-radius: 10px; font-weight: 600; font-size: 1rem; cursor: pointer; transition: all 0.2s ease-out; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 2px 5px var(--shadow-light); }
        .actions-group button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px var(--shadow-medium); }
        .actions-group button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 1px 3px var(--shadow-light); }
        .actions-group button:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none; }
        .btn-roll { font-size: 1.15rem; padding: 16px; }
        .btn-roll.reset-mode { background-color: var(--failure); color: white; }
        .btn-roll.roll-mode { background: linear-gradient(145deg, var(--success), #239b56); color: white; }
        .special-action-buttons-container { display: flex; justify-content: center; gap: 12px; margin-bottom: 25px; min-height: 44px; }
        .special-action-buttons-container button { padding: 10px 18px; border: none; border-radius: 8px; font-weight: 600; font-size: 0.9rem; cursor: pointer; background-color: #f1c40f; color: var(--text-primary); box-shadow: 0 2px 5px var(--shadow-light); transition: all 0.2s ease-out; }
        .special-action-buttons-container button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px var(--shadow-medium); filter: brightness(1.05); }
        .special-action-buttons-container button:disabled { opacity: 0.5; background-color: var(--text-secondary); cursor: not-allowed; box-shadow: none; }
        .modal { position: fixed; top:0; left:0; right:0; bottom:0; background-color:rgba(20,30,40,0.6); display:flex; align-items:center; justify-content:center; z-index:1000; padding:20px; backdrop-filter:blur(3px); }
        .modal-content { background-color:var(--bg-secondary); padding:30px 35px; border-radius:16px; width:100%; max-width:480px; box-shadow:0 8px 25px rgba(44,62,80,0.2); }
        .modal-content h2 { text-align:center; margin-top:0; margin-bottom:25px; color:var(--countdown-ring-normal-fill); font-size:1.6rem; }
        .form-group { margin-bottom:22px; }
        .form-group label { display:block; margin-bottom:8px; font-weight:500; color:var(--text-secondary); font-size:0.9rem; }
        .form-group input[type="text"], .form-group input[type="file"] { width:100%; padding:12px 15px; border-radius:8px; border:1px solid var(--border-color); background-color:var(--bg-primary); color:var(--text-primary); font-size:1rem; transition:border-color .2s,box-shadow .2s; }
        .form-group input[type="text"]:focus, .form-group input[type="file"]:focus { outline:none; border-color:var(--countdown-ring-normal-fill); box-shadow:0 0 0 3px rgba(41,128,185,0.2); }
        .form-group input[type="file"] { padding:10px 15px; }
        .image-preview { margin-top:15px; width:100px; height:100px; border-radius:50%; overflow:hidden; border:3px solid var(--border-color); box-shadow:0 2px 4px var(--shadow-light); }
        .image-preview img { width:100%; height:100%; object-fit:cover; }
        .modal-actions { display:flex; justify-content:flex-end; gap:12px; margin-top:30px; }
        .modal-actions button { padding:10px 22px; border:none; border-radius:8px; font-weight:600; font-size:0.95rem; cursor:pointer; transition:all .2s ease-out; }
        .modal-actions button:first-child { background-color:transparent; color:var(--text-secondary); border:1px solid var(--border-color); }
        .modal-actions button:first-child:hover { background-color:var(--bg-tertiary); }
        .modal-actions button:last-child { background-color:var(--countdown-ring-normal-fill); color:white; box-shadow:0 2px 5px var(--shadow-light); }
        .modal-actions button:last-child:hover { background-color:#2471a3; box-shadow:0 3px 7px var(--shadow-medium); }
        .modal-actions button:disabled { opacity:.5; cursor:not-allowed; box-shadow:none!important; }
    </style>
</head>
<body>
  <div class="dice-roller-app">
    <div class="app-title-header">
      <h1>DICE ROLLER</h1>
    </div>

    <div class="main-layout-container">
      <div class="left-column players-section">
        <h2>Players</h2>
        <div id="playerList" class="player-list">
          <!-- Player items will be rendered here by JS -->
        </div>
        <button id="openAddPlayerModalBtn" class="add-player-button" title="Add New Player">
          + Add Player
        </button>
        <p id="noPlayersText" class="no-players-text" style="display: none;">No players yet. Click '+' to add.</p>
      </div>

      <div class="right-column">
        <header class="controls-header">
          <div class="difficulty-control">
            <span class="difficulty-label">DIFFICULTY:</span>
            <div class="difficulty-buttons-group">
              <button id="decreaseDifficultyBtn">-</button>
              <span id="difficultyDisplay">2</span>
              <button id="increaseDifficultyBtn">+</button>
            </div>
          </div>
        </header>

        <div id="dicePoolDisplay" class="dice-pool-display">
          <!-- Dice slots will be rendered here by JS -->
        </div>

        <div class="tension-timers-section">
          <div class="timer-controls-row">
            <div class="timer-control-group">
              <div class="timer-label">Tension Timer</div>
              <div class="visual-timer-container" id="tensionTimerVisualContainer">
                  <svg class="timer-svg-border">
                      <defs>
                          <linearGradient id="tensionGradientNormal" x1="0%" y1="0%" x2="100%" y2="0%">
                              <stop offset="0%" stop-color="var(--timer-gradient-normal-start)" />
                              <stop offset="100%" stop-color="var(--timer-gradient-normal-end)" />
                          </linearGradient>
                          <linearGradient id="tensionGradientWarning" x1="0%" y1="0%" x2="100%" y2="0%">
                              <stop offset="0%" stop-color="var(--timer-gradient-warning-start)" />
                              <stop offset="100%" stop-color="var(--timer-gradient-warning-end)" />
                          </linearGradient>
                          <linearGradient id="tensionGradientDanger" x1="0%" y1="0%" x2="100%" y2="0%">
                              <stop offset="0%" stop-color="var(--timer-gradient-danger-start)" />
                              <stop offset="100%" stop-color="var(--timer-gradient-danger-end)" />
                          </linearGradient>
                      </defs>
                      <rect id="tensionTimerSvgBorderRect" />
                  </svg>
                  <span id="tensionTimerText" class="timer-text-content">16s</span>
              </div>
              <div class="timer-buttons">
                <button id="startTensionTimerBtn" class="timer-btn">START</button>
                <button id="pauseTensionTimerBtn" class="timer-btn" style="display: none;">PAUSE</button>
                <button id="resetTensionTimerBtn" class="timer-btn">RESET</button>
              </div>
            </div>

            <div class="timer-control-group">
              <div class="timer-label">Countdown Clock</div>
               <div class="visual-timer-display-area">
                  <div class="visual-timer-container" id="countdownVisualContainer">
                      <svg class="countdown-pie-svg" viewBox="0 0 50 50">
                          <circle class="countdown-ring-track" cx="25" cy="25" r="20"></circle>
                          <circle id="countdownRingFillSegment" class="countdown-ring-fill-segment" cx="25" cy="25" r="20"></circle>
                      </svg>
                      <span id="countdownText" class="countdown-text-content">3 / 6</span>
                  </div>
                  <div class="countdown-buttons-group">
                    <button id="increaseCountdownBtn">+</button>
                    <button id="decreaseCountdownBtn">-</button>
                  </div>
              </div>
              <button id="resetCountdownBtn" class="timer-btn">RESET</button>
            </div>
          </div>
        </div>

        <div id="statusMessage" class="status">Ready to roll!</div>

        <div class="actions-group">
          <button id="rollDiceBtn" class="btn-roll roll-mode">Roll Dice</button>
          <div id="specialActionButtonsContainer" class="special-action-buttons-container">
            <button id="pushLuckBtn" style="display:none;">Push Your Luck</button>
            <button id="payPriceBtn" style="display:none;">Pay Price & Redo Roll</button>
          </div>
        </div>
      </div>
    </div>

    <div id="addPlayerModal" class="modal" style="display: none;">
      <div class="modal-content">
        <h2>Add New Player</h2>
        <div class="form-group">
          <label for="playerNameInput">Player Name</label>
          <input id="playerNameInput" type="text" />
        </div>
        <div class="form-group">
          <label for="playerImageInput">Profile Image (Optional)</label>
          <input id="playerImageInput" type="file" accept="image/*" />
          <div id="imagePreviewContainer" class="image-preview" style="display:none;">
            <img id="imagePreview" src="#" alt="Preview" />
          </div>
        </div>
        <div class="modal-actions">
          <button id="cancelAddPlayerBtn">Cancel</button>
          <button id="confirmAddPlayerBtn">Add Player</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- GLOBAL STATE & CONFIG ---
    let difficulty = 2;
    let expertise = 0; 
    let specialMoves = 0; 
    let rolls = []; 
    let outcomeText = "";
    let isRolling = false; 
    let hasRolledThisTurn = false; 
    let canPushLuck = false; 
    let canPayPrice = false; 
    let pushedLuckDieRoll = null; 
    let isRedoingRollAfterPrice = false; 
    let indexOfRollToRedo = -1; 

    let players = []; 
    let diceContributions = []; 
    let specialMoveContributions = []; 

    let uploadedImage = null; 

    let currentRollIndex = null; 
    let currentAnimatedValue = null; 
    let sequenceChainTimeoutId = null; 
    let currentSequenceTotalDice = 0; 

    let nextPlayerHue = 0;
    const HUE_INCREMENT = 37; 
    const SATURATION = 70; 
    const LIGHTNESS = 55; 

    let tensionTimerInterval = null;
    let isTensionTimerRunning = false;
    let tensionTimerStartTime = 0; 
    let tensionTimerPausedTime = 0; 
    let tensionTimerSeconds; 
    let tensionTimerBorderPerimeter = 0; // For SVG border animation

    let countdownClock = 3; 
    const COUNTDOWN_RING_MAX_VALUE = 6; // Denominator
    const RING_RADIUS = 20; 
    const RING_CIRCUMFERENCE = 2 * Math.PI * RING_RADIUS;


    const SINGLE_DIE_ANIMATION_FRAMES = 12; 
    const SINGLE_DIE_ANIMATION_INTERVAL = 60; 
    const SINGLE_DIE_POST_ANIMATION_PAUSE = 350; 
    const BASE_DELAY_AFTER_DIE_FINISHES = 150; 
    const DELAY_INCREMENT_PER_DIE = 75; 

    document.addEventListener('DOMContentLoaded', () => {
        const dicePoolDisplayEl = document.getElementById('dicePoolDisplay');
        const playerListEl = document.getElementById('playerList');
        const noPlayersTextEl = document.getElementById('noPlayersText');
        const statusMessageEl = document.getElementById('statusMessage');
        const rollDiceBtn = document.getElementById('rollDiceBtn');
        const pushLuckBtn = document.getElementById('pushLuckBtn');
        const payPriceBtn = document.getElementById('payPriceBtn');
        const openAddPlayerModalBtn = document.getElementById('openAddPlayerModalBtn');

        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const decreaseDifficultyBtn = document.getElementById('decreaseDifficultyBtn');
        const increaseDifficultyBtn = document.getElementById('increaseDifficultyBtn');

        const tensionTimerVisualContainer = document.getElementById('tensionTimerVisualContainer');
        const tensionTimerTextEl = document.getElementById('tensionTimerText');
        const tensionTimerSvgBorderRectEl = document.getElementById('tensionTimerSvgBorderRect');
        const startTensionTimerBtn = document.getElementById('startTensionTimerBtn');
        const pauseTensionTimerBtn = document.getElementById('pauseTensionTimerBtn');
        const resetTensionTimerBtn = document.getElementById('resetTensionTimerBtn');

        const countdownVisualContainer = document.getElementById('countdownVisualContainer');
        const countdownTextEl = document.getElementById('countdownText');
        const countdownRingFillSegmentEl = document.getElementById('countdownRingFillSegment');
        const decreaseCountdownBtn = document.getElementById('decreaseCountdownBtn');
        const increaseCountdownBtn = document.getElementById('increaseCountdownBtn');
        const resetCountdownBtn = document.getElementById('resetCountdownBtn');

        const addPlayerModalEl = document.getElementById('addPlayerModal');
        const playerNameInput = document.getElementById('playerNameInput');
        const playerImageInput = document.getElementById('playerImageInput');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreviewEl = document.getElementById('imagePreview');
        const cancelAddPlayerBtn = document.getElementById('cancelAddPlayerBtn');
        const confirmAddPlayerBtn = document.getElementById('confirmAddPlayerBtn');

        const DICE_ICON = 'ðŸŽ²';
        const STAR_ICON = 'âœ¨';
        const USER_ICON = 'ðŸ‘¤';

        // Calculate perimeter for tension timer SVG border once
        const rectWidth = tensionTimerVisualContainer.clientWidth - 6; // Subtract stroke width
        const rectHeight = tensionTimerVisualContainer.clientHeight - 6;
        tensionTimerBorderPerimeter = 2 * (rectWidth + rectHeight);
        tensionTimerSvgBorderRectEl.style.strokeDasharray = tensionTimerBorderPerimeter;


        function generatePlayerColor() {
            const hue = nextPlayerHue;
            nextPlayerHue = (nextPlayerHue + HUE_INCREMENT) % 360;
            return `hsl(${hue}, ${SATURATION}%, ${LIGHTNESS}%)`;
        }

        function calculateTensionTimerDuration() {
            if (difficulty <= 0) return 0; 
            let secondsPerDie = 8.0;
            if (difficulty > 1) secondsPerDie -= (difficulty - 1) * 0.5;
            secondsPerDie = Math.ceil(secondsPerDie);
            secondsPerDie = Math.max(3, secondsPerDie);
            return secondsPerDie * difficulty;
        }

        function updateTensionTimerDisplay() {
            const totalSeconds = calculateTensionTimerDuration();
            const minutes = Math.floor(tensionTimerSeconds / 60);
            const seconds = tensionTimerSeconds % 60;
            
            let displayText;
            if (minutes > 0) {
                displayText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                displayText = `${seconds}s`;
            }
            tensionTimerTextEl.textContent = displayText;

            let fillPercentage = 0;
            if (totalSeconds > 0) {
                fillPercentage = Math.max(0, (tensionTimerSeconds / totalSeconds));
            } else if (tensionTimerSeconds <= 0) {
                 fillPercentage = 0;
            } else { 
                 fillPercentage = 1; // Full if total is 0 but current isn't (edge case)
            }
            
            // Animate SVG border: offset goes from 0 (full) to perimeter (empty)
            // To make it "undraw", we want offset to increase as time decreases
            const borderOffset = tensionTimerBorderPerimeter * (1 - fillPercentage);
            tensionTimerSvgBorderRectEl.style.strokeDashoffset = borderOffset;
            
            // Default to normal state styles
            let currentGradientUrl = 'url(#tensionGradientNormal)';
            let currentTextColorVar = 'var(--timer-text-normal-color)';
            tensionTimerVisualContainer.classList.remove('warning', 'danger');


            if (totalSeconds > 0) {
                const percentRemaining = tensionTimerSeconds / totalSeconds;
                if (tensionTimerSeconds <= 0) { // Expired
                    tensionTimerVisualContainer.classList.add('danger');
                    currentGradientUrl = 'url(#tensionGradientDanger)';
                    currentTextColorVar = 'var(--timer-text-danger-color)';
                } else if (percentRemaining <= 0.25) { // Danger zone
                    tensionTimerVisualContainer.classList.add('danger');
                    currentGradientUrl = 'url(#tensionGradientDanger)';
                    currentTextColorVar = 'var(--timer-text-danger-color)';
                } else if (percentRemaining <= 0.5) { // Warning zone
                    tensionTimerVisualContainer.classList.add('warning');
                    currentGradientUrl = 'url(#tensionGradientWarning)';
                    currentTextColorVar = 'var(--timer-text-warning-color)';
                }
            } else { 
                 tensionTimerSvgBorderRectEl.style.strokeDashoffset = tensionTimerBorderPerimeter; // Empty border
            }
            tensionTimerSvgBorderRectEl.style.stroke = currentGradientUrl;
            tensionTimerTextEl.style.backgroundImage = `linear-gradient(90deg, var(${currentGradientUrl.includes('Warning') ? '--timer-gradient-warning-start' : currentGradientUrl.includes('Danger') ? '--timer-gradient-danger-start' : '--timer-gradient-normal-start'}), var(${currentGradientUrl.includes('Warning') ? '--timer-gradient-warning-end' : currentGradientUrl.includes('Danger') ? '--timer-gradient-danger-end' : '--timer-gradient-normal-end'}))`;
            // Fallback solid color if gradient text fails or for simplicity
            // tensionTimerTextEl.style.color = `var(${currentTextColorVar.slice(4, -1)})`; // Use the variable value directly
            // For gradient text, color must be transparent. The classList can handle fallback.
            tensionTimerTextEl.classList.remove('normal', 'warning', 'danger');
            if (currentGradientUrl.includes('Warning')) tensionTimerTextEl.classList.add('warning');
            else if (currentGradientUrl.includes('Danger')) tensionTimerTextEl.classList.add('danger');
            else tensionTimerTextEl.classList.add('normal');

        }

        function startTensionTimer() {
            if (isTensionTimerRunning) return;
            const totalDurationForThisRun = calculateTensionTimerDuration();
            if (totalDurationForThisRun <= 0) {
                tensionTimerSeconds = 0;
                tensionTimerPausedTime = 0;
                isTensionTimerRunning = false;
                if (tensionTimerInterval) clearInterval(tensionTimerInterval);
                updateTensionTimerDisplay();
                startTensionTimerBtn.style.display = 'inline-block';
                pauseTensionTimerBtn.style.display = 'none';
                return;
            }
            isTensionTimerRunning = true;
            tensionTimerStartTime = Date.now() - tensionTimerPausedTime;
            tensionTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - tensionTimerStartTime) / 1000);
                tensionTimerSeconds = Math.max(0, totalDurationForThisRun - elapsed);
                updateTensionTimerDisplay();
                if (tensionTimerSeconds <= 0) {
                    pauseTensionTimer();
                    outcomeText = "Time's up! Auto-fail due to tension timer expiring.";
                    hasRolledThisTurn = true; 
                    isRolling = false; 
                    fullUIUpdate(); 
                }
            }, 100);
            startTensionTimerBtn.style.display = 'none';
            pauseTensionTimerBtn.style.display = 'inline-block';
        }

        function pauseTensionTimer() {
            if (!isTensionTimerRunning) return;
            isTensionTimerRunning = false;
            clearInterval(tensionTimerInterval);
            tensionTimerPausedTime = Date.now() - tensionTimerStartTime;
            startTensionTimerBtn.style.display = 'inline-block';
            pauseTensionTimerBtn.style.display = 'none';
        }

        function resetTensionTimer() {
            pauseTensionTimer();
            tensionTimerSeconds = calculateTensionTimerDuration();
            tensionTimerPausedTime = 0;
            updateTensionTimerDisplay();
        }

        function updateCountdownDisplay() {
            countdownTextEl.textContent = `${countdownClock} / ${COUNTDOWN_RING_MAX_VALUE}`;
            const fillPercentage = Math.min(1, Math.max(0, countdownClock / COUNTDOWN_RING_MAX_VALUE));
            const offset = RING_CIRCUMFERENCE * (1 - fillPercentage);
            
            countdownRingFillSegmentEl.style.strokeDasharray = `${RING_CIRCUMFERENCE}`;
            countdownRingFillSegmentEl.style.strokeDashoffset = `${offset}`;

            // Reset to normal colors first
            countdownRingFillSegmentEl.style.stroke = 'var(--countdown-ring-normal-fill)';
            countdownTextEl.style.color = 'var(--countdown-text-normal-color)';

            if (countdownClock <= Math.floor(COUNTDOWN_RING_MAX_VALUE * 0.25) && countdownClock > 0 && COUNTDOWN_RING_MAX_VALUE > 1) { // Danger (e.g., 1/6)
                countdownRingFillSegmentEl.style.stroke = 'var(--timer-gradient-danger-end)'; // Use a solid color from danger gradient
                countdownTextEl.style.color = 'var(--timer-text-danger-color)';
            } else if (countdownClock <= Math.floor(COUNTDOWN_RING_MAX_VALUE * 0.5) && countdownClock > 0) { // Warning (e.g., 2/6, 3/6)
                countdownRingFillSegmentEl.style.stroke = 'var(--timer-gradient-warning-end)'; // Use a solid color from warning gradient
                countdownTextEl.style.color = 'var(--timer-text-warning-color)';
            }
             if (countdownClock === 0) { 
                countdownTextEl.style.color = 'var(--text-secondary)'; 
             }
        }


        function adjustCountdownClock(amount) {
            if (isRolling || hasRolledThisTurn) return;
            countdownClock = Math.max(0, countdownClock + amount); 
            // No upper limit for the clock value itself, but visualization is capped by COUNTDOWN_RING_MAX_VALUE
            countdownClock = Math.min(countdownClock, 99); // Arbitrary practical upper limit for display
            updateCountdownDisplay();
        }

        function resetCountdownClock() {
            if (isRolling || hasRolledThisTurn) return;
            countdownClock = 3; // Or initial value, ensure it's within reasonable bounds for N/M display
            updateCountdownDisplay();
        }

        const getNumSpecialMovesVisuallyCoveringSlots = () => Math.min(specialMoves, Math.max(0, difficulty));
        const getNumPrimarySlotsForExpertiseOrEmpty = () => {
            const coveredBySM = getNumSpecialMovesVisuallyCoveringSlots();
            return Math.max(0, difficulty - coveredBySM);
        };
        const getDicePool = () => expertise;

        function renderDicePool() {
            dicePoolDisplayEl.innerHTML = '';
            let expertiseDieRenderedCount = 0;
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();

            for (let i = 0; i < Math.max(0, difficulty); i++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('dice-slot');
                const isCoveredBySpecialMove = i >= Math.max(0, difficulty) - numSMCovers;

                if (isCoveredBySpecialMove) {
                    slotDiv.classList.add('special-move-covered');
                    const smContributionIndex = (numSMCovers - 1) - (i - (Math.max(0, difficulty) - numSMCovers));
                    const playerId = specialMoveContributions[smContributionIndex];
                    const player = playerId ? players.find(p => p.id === playerId) : null;

                    if (player && player.image) {
                        const img = document.createElement('img');
                        img.classList.add('player-cover-image');
                        img.src = player.image;
                        img.alt = `${player.name} covers this`;
                        img.title = `${player.name} covers this difficulty`;
                        slotDiv.appendChild(img);
                    } else if (player) {
                         const initialDiv = document.createElement('div');
                         initialDiv.classList.add('player-initial-avatar');
                         initialDiv.style.width = '100%';
                         initialDiv.style.height = '100%';
                         initialDiv.style.borderRadius = '8px';
                         initialDiv.textContent = player.name.charAt(0).toUpperCase();
                         initialDiv.title = `${player.name} covers this difficulty (Initial)`;
                         initialDiv.style.backgroundColor = player.color;
                         slotDiv.appendChild(initialDiv);
                    } else {
                        const genericCoverDiv = document.createElement('div');
                        genericCoverDiv.classList.add('player-cover-image', 'generic-cover');
                        genericCoverDiv.innerHTML = STAR_ICON;
                        genericCoverDiv.title = "Special Move covers this";
                        slotDiv.appendChild(genericCoverDiv);
                    }
                } else {
                    if (expertiseDieRenderedCount < expertise) {
                        slotDiv.classList.add('filled');
                        const currentExpertiseDieOriginalIndex = expertiseDieRenderedCount;
                        const playerIdForExpertise = diceContributions[currentExpertiseDieOriginalIndex];
                        const playerForExpertise = playerIdForExpertise ? players.find(p => p.id === playerIdForExpertise) : null;

                        const dieFaceDiv = document.createElement('div');
                        dieFaceDiv.classList.add('die-face');
                        let content = DICE_ICON;
                        dieFaceDiv.classList.add('placeholder');

                        if ((isRolling || isRedoingRollAfterPrice) && currentExpertiseDieOriginalIndex === currentRollIndex && currentAnimatedValue !== null) {
                            content = currentAnimatedValue;
                            dieFaceDiv.classList.remove('placeholder', 'waiting', 'filled-placeholder');
                            if (currentAnimatedValue === 6) dieFaceDiv.classList.add('success', 'animating');
                            else if (currentAnimatedValue === 1) dieFaceDiv.classList.add('failure', 'animating');
                            else if (currentAnimatedValue >= 4) dieFaceDiv.classList.add('partial-success', 'animating');
                            else dieFaceDiv.classList.add('partial-failure', 'animating');
                        } else if (rolls[currentExpertiseDieOriginalIndex] !== undefined) {
                            content = rolls[currentExpertiseDieOriginalIndex];
                            dieFaceDiv.classList.remove('placeholder', 'waiting', 'filled-placeholder');
                            if (rolls[currentExpertiseDieOriginalIndex] === 6) dieFaceDiv.classList.add('success');
                            else if (rolls[currentExpertiseDieOriginalIndex] === 1) dieFaceDiv.classList.add('failure');
                            else if (rolls[currentExpertiseDieOriginalIndex] >= 4) dieFaceDiv.classList.add('partial-success');
                            else dieFaceDiv.classList.add('partial-failure');
                        } else if (isRolling || isRedoingRollAfterPrice) {
                            dieFaceDiv.classList.add("waiting");
                        } else {
                            dieFaceDiv.classList.add("filled-placeholder");
                        }
                        dieFaceDiv.innerHTML = content;
                        slotDiv.appendChild(dieFaceDiv);

                        if (playerForExpertise) {
                            const indicator = document.createElement('div');
                            indicator.classList.add('player-indicator');
                            indicator.title = `Expertise from ${playerForExpertise.name}`;
                            if (playerForExpertise.image) {
                                const imgPlayerIndicator = document.createElement('img');
                                imgPlayerIndicator.src = playerForExpertise.image;
                                imgPlayerIndicator.alt = playerForExpertise.name;
                                indicator.appendChild(imgPlayerIndicator);
                            } else {
                                indicator.classList.add('generic');
                                indicator.textContent = playerForExpertise.name.charAt(0).toUpperCase();
                                indicator.style.backgroundColor = playerForExpertise.color;
                            }
                            slotDiv.appendChild(indicator);
                        }
                        expertiseDieRenderedCount++;
                    } else {
                        slotDiv.classList.add('empty');
                    }
                }
                dicePoolDisplayEl.appendChild(slotDiv);
            }

            for (let k = expertiseDieRenderedCount; k < expertise; k++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('dice-slot', 'extra');
                const currentExpertiseDieOriginalIndex = k;
                const playerIdForExpertise = diceContributions[currentExpertiseDieOriginalIndex];
                const playerForExpertise = playerIdForExpertise ? players.find(p => p.id === playerIdForExpertise) : null;

                const dieFaceDiv = document.createElement('div');
                dieFaceDiv.classList.add('die-face');
                let content = DICE_ICON;
                dieFaceDiv.classList.add('placeholder');

                if ((isRolling || isRedoingRollAfterPrice) && currentExpertiseDieOriginalIndex === currentRollIndex && currentAnimatedValue !== null) {
                    content = currentAnimatedValue;
                    dieFaceDiv.classList.remove('placeholder', 'waiting', 'filled-placeholder');
                    if (currentAnimatedValue === 6) dieFaceDiv.classList.add('success', 'animating');
                    else if (currentAnimatedValue === 1) dieFaceDiv.classList.add('failure', 'animating');
                    else if (currentAnimatedValue >= 4) dieFaceDiv.classList.add('partial-success', 'animating');
                    else dieFaceDiv.classList.add('partial-failure', 'animating');
                } else if (rolls[currentExpertiseDieOriginalIndex] !== undefined) {
                    content = rolls[currentExpertiseDieOriginalIndex];
                    dieFaceDiv.classList.remove('placeholder', 'waiting', 'filled-placeholder');
                    if (rolls[currentExpertiseDieOriginalIndex] === 6) dieFaceDiv.classList.add('success');
                    else if (rolls[currentExpertiseDieOriginalIndex] === 1) dieFaceDiv.classList.add('failure');
                    else if (rolls[currentExpertiseDieOriginalIndex] >= 4) dieFaceDiv.classList.add('partial-success');
                    else dieFaceDiv.classList.add('partial-failure');
                } else if (isRolling || isRedoingRollAfterPrice) {
                    dieFaceDiv.classList.add("waiting");
                } else {
                    dieFaceDiv.classList.add("filled-placeholder");
                }
                dieFaceDiv.innerHTML = content;
                slotDiv.appendChild(dieFaceDiv);

                if (playerForExpertise) {
                    const indicator = document.createElement('div');
                    indicator.classList.add('player-indicator');
                    indicator.title = `Expertise from ${playerForExpertise.name}`;
                     if (playerForExpertise.image) {
                        const imgPlayerIndicator = document.createElement('img');
                        imgPlayerIndicator.src = playerForExpertise.image;
                        imgPlayerIndicator.alt = playerForExpertise.name;
                        indicator.appendChild(imgPlayerIndicator);
                    } else {
                        indicator.classList.add('generic');
                        indicator.textContent = playerForExpertise.name.charAt(0).toUpperCase();
                        indicator.style.backgroundColor = playerForExpertise.color;
                    }
                    slotDiv.appendChild(indicator);
                }
                dicePoolDisplayEl.appendChild(slotDiv);
            }
            if (pushedLuckDieRoll !== null && !isRolling && !isRedoingRollAfterPrice) {
                const pushedDieSlot = document.createElement('div');
                pushedDieSlot.classList.add('dice-slot', 'filled');
                pushedDieSlot.style.borderColor = '#f1c40f'; // General warning yellow
                const dieFaceDiv = document.createElement('div');
                dieFaceDiv.classList.add('die-face', 'pushed-luck-die');
                 if (pushedLuckDieRoll <= 3) dieFaceDiv.classList.add('failure'); else dieFaceDiv.classList.add('success');
                dieFaceDiv.textContent = pushedLuckDieRoll;
                pushedDieSlot.appendChild(dieFaceDiv);
                dicePoolDisplayEl.appendChild(pushedDieSlot);
            }
        }

        function renderPlayerList() {
            playerListEl.innerHTML = '';
            noPlayersTextEl.style.display = players.length === 0 ? 'block' : 'none';
            players.forEach(player => {
                const playerItemDiv = document.createElement('div');
                playerItemDiv.classList.add('player-item');
                const playerInfoDiv = document.createElement('div');
                playerInfoDiv.classList.add('player-info');
                const avatarContainer = document.createElement('div');
                avatarContainer.classList.add('player-avatar-container');
                if (player.image) {
                    const img = document.createElement('img');
                    img.src = player.image; img.alt = player.name; img.classList.add('player-avatar-img');
                    avatarContainer.appendChild(img);
                } else {
                    const initialDiv = document.createElement('div');
                    initialDiv.classList.add('player-initial-avatar');
                    initialDiv.textContent = player.name.charAt(0).toUpperCase();
                    initialDiv.style.backgroundColor = player.color;
                    avatarContainer.appendChild(initialDiv);
                }
                playerInfoDiv.appendChild(avatarContainer);
                const nameLabel = document.createElement('span');
                nameLabel.classList.add('player-name-label'); nameLabel.textContent = player.name;
                playerInfoDiv.appendChild(nameLabel);
                playerItemDiv.appendChild(playerInfoDiv);
                const actionIconsDiv = document.createElement('div');
                actionIconsDiv.classList.add('player-action-icons');
                const addExpertiseBtn = document.createElement('button');
                addExpertiseBtn.classList.add('player-action-btn'); addExpertiseBtn.innerHTML = DICE_ICON;
                addExpertiseBtn.title = `Add Expertise (${player.contributedDice}/3)`;
                addExpertiseBtn.disabled = player.contributedDice >= 3 || isRolling || canPushLuck || canPayPrice || isRedoingRollAfterPrice || hasRolledThisTurn;
                addExpertiseBtn.addEventListener('click', () => handlePlayerContributesExpertise(player.id));
                actionIconsDiv.appendChild(addExpertiseBtn);
                const addSpecialMoveBtn = document.createElement('button');
                addSpecialMoveBtn.classList.add('player-action-btn'); addSpecialMoveBtn.innerHTML = STAR_ICON;
                addSpecialMoveBtn.title = `Add Special Move`;
                const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();
                addSpecialMoveBtn.disabled = (difficulty > 0 && numSMCovers >= difficulty) || isRolling || canPushLuck || canPayPrice || isRedoingRollAfterPrice || hasRolledThisTurn;
                addSpecialMoveBtn.addEventListener('click', () => handlePlayerContributesSpecialMove(player.id));
                actionIconsDiv.appendChild(addSpecialMoveBtn);
                playerItemDiv.appendChild(actionIconsDiv);
                playerListEl.appendChild(playerItemDiv);
            });
        }

        function updateStatusMessage() {
            let msg = "Ready to roll!";
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();
            const numPrimarySlotsNeeded = getNumPrimarySlotsForExpertiseOrEmpty();
            const currentDicePool = getDicePool();

            if (isRolling && !isRedoingRollAfterPrice) {
                msg = "Rolling dice...";
            } else if (isRedoingRollAfterPrice) {
                msg = `Redo the roll of 1! (Price: ${outcomeText.split("Price Paid: ")[1]?.split(". Redo")[0] || 'Paid'})`;
            } else if (canPushLuck) {
                msg = `A 6! Push your luck? Or Reset.`;
            } else if (canPayPrice) {
                 msg = `A 1! Pay a price to redo this die and continue? Or Reset.`;
            } else if (outcomeText) {
                msg = outcomeText;
                 if (rolls.length > 0 && !isRolling && !isRedoingRollAfterPrice) {
                     msg += ` (XP: ${rolls.length * 10})`; 
                     if(pushedLuckDieRoll !== null) msg += ` (Pushed Luck Die: ${pushedLuckDieRoll})`;
                 }
            } else if (currentDicePool === 0 && difficulty > 0 && numSMCovers < difficulty) {
                msg = `Add expertise dice to attempt Difficulty ${difficulty}.`;
            } else if (expertise < numPrimarySlotsNeeded) {
                const needed = numPrimarySlotsNeeded - expertise;
                msg = `Need ${needed} more expertise ${needed === 1 ? 'die' : 'dice'} to cover Difficulty ${difficulty}.`;
            }
            statusMessageEl.textContent = msg;
        }

        function updateActionButtons() {
            const currentDicePool = getDicePool();
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();

            rollDiceBtn.classList.remove('roll-mode', 'reset-mode');

            if (hasRolledThisTurn && !isRolling && !isRedoingRollAfterPrice) {
                rollDiceBtn.textContent = "Reset & Prepare Next Roll";
                rollDiceBtn.disabled = false;
                rollDiceBtn.classList.add('reset-mode');
            } else if (isRedoingRollAfterPrice) {
                rollDiceBtn.textContent = "Redo Failed Roll";
                rollDiceBtn.disabled = isRolling; 
                rollDiceBtn.classList.add('roll-mode');
            } else {
                rollDiceBtn.textContent = isRolling ? "Rolling..." : "Roll Dice";
                rollDiceBtn.disabled =
                    (difficulty > 0 && currentDicePool === 0 && numSMCovers < difficulty) || 
                    isRolling || 
                    expertise < getNumPrimarySlotsForExpertiseOrEmpty(); 
                rollDiceBtn.classList.add('roll-mode');
            }
            pushLuckBtn.style.display = canPushLuck ? 'inline-block' : 'none';
            payPriceBtn.style.display = canPayPrice ? 'inline-block' : 'none';
        }

        function updateDifficultyDisplay() {
            difficultyDisplay.textContent = difficulty;
            if (!isTensionTimerRunning) { 
                 resetTensionTimer(); 
            }
        }

        function determineSingleDieOpportunity(die) {
             if (!canPushLuck && !canPayPrice) { 
                if (die === 6) {
                    canPushLuck = true;
                } else if (die === 1) {
                    canPayPrice = true;
                }
             }
        }

        function finalizeOverallOutcome(diceArray) {
            outcomeText = ""; 
            if (isTensionTimerRunning) {
                pauseTensionTimer();
            }
            
            if (canPushLuck || canPayPrice || isRedoingRollAfterPrice || pushedLuckDieRoll !== null) {
                 if(!canPushLuck && !canPayPrice && !isRedoingRollAfterPrice && pushedLuckDieRoll !== null) {
                 } else {
                    return; 
                 }
            }

             if (diceArray.length === 0 && getDicePool() === 0 && getNumSpecialMovesVisuallyCoveringSlots() >= difficulty && difficulty > 0) {
                 outcomeText = "Success! Difficulty covered by special moves, no roll needed.";
                 return;
             }

             if (diceArray.length === 0 && getDicePool() === 0 && !(getNumSpecialMovesVisuallyCoveringSlots() >= difficulty && difficulty > 0)) {
                if (hasRolledThisTurn) { 
                   outcomeText = "No dice rolled. Outcome determined by situation or requires dice."; return;
                } else { 
                    return;
                }
             }
             
             if (diceArray.length === 0) return; 

            const highest = Math.max(...diceArray);
            if (highest === 6 && !diceArray.includes(1)) outcomeText = "Success! The goal is achieved, cleanly.";
            else if (highest === 6 && diceArray.includes(1)) outcomeText = "Critical Success with a major complication (6 and 1)!";
            else if (highest === 1) outcomeText = "Failure! Face consequences, loss, or harm.";
            else if (highest <= 3) outcomeText = "Failure with a silver lining (2-3)"; 
            else outcomeText = "Success with a complication (4-5)"; 
            
            if (countdownClock > 0 && !isRedoingRollAfterPrice && !canPushLuck && !canPayPrice) { // Only decrement if it's a "final" roll outcome for the turn
                countdownClock--;
            }
        }

        function fullUIUpdate() {
            updateDifficultyDisplay(); 
            renderDicePool();
            renderPlayerList();
            updateActionButtons();
            updateStatusMessage();
            updateTensionTimerDisplay(); 
            updateCountdownDisplay();
        }

        function handleImageUploadJS(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => { uploadedImage = e.target.result; imagePreviewEl.src = uploadedImage; imagePreviewContainer.style.display = 'block'; };
                reader.readAsDataURL(file);
            } else {
                uploadedImage = null;
                imagePreviewContainer.style.display = 'none';
                imagePreviewEl.src = "#";
            }
        }

        function addPlayerJS() {
            const name = playerNameInput.value.trim();
            if (name) {
                players.push({
                    id: Date.now(), name, image: uploadedImage,
                    contributedDice: 0, contributedSpecialMoves: 0,
                    color: generatePlayerColor()
                });
                playerNameInput.value = ''; playerImageInput.value = ''; uploadedImage = null;
                imagePreviewContainer.style.display = 'none'; imagePreviewEl.src = "#";
                addPlayerModalEl.style.display = 'none';
                fullUIUpdate();
            } else { alert("Player name is required."); }
        }

        function handlePlayerContributesExpertise(playerId) {
            if (hasRolledThisTurn || isRolling || canPushLuck || canPayPrice || isRedoingRollAfterPrice) return;
            const playerIndex = players.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;
            if (players[playerIndex].contributedDice < 3) {
                players[playerIndex].contributedDice += 1;
                diceContributions.push(playerId); expertise += 1;
                fullUIUpdate();
            } else { alert(`${players[playerIndex].name} has reached the maximum of 3 expertise contributions.`); }
        }

        function handlePlayerContributesSpecialMove(playerId) {
             if (hasRolledThisTurn || isRolling || canPushLuck || canPayPrice || isRedoingRollAfterPrice) return;
            const playerIndex = players.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return;
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();
            if (difficulty > 0 && numSMCovers >= difficulty) {
                alert("All difficulty slots are already covered by special moves."); return;
            }
            players[playerIndex].contributedSpecialMoves += 1;
            specialMoveContributions.push(playerId); specialMoves += 1;
            fullUIUpdate();
        }

        function clearAllContributionsAndStatsJS() {
            players.forEach(p => { p.contributedDice = 0; p.contributedSpecialMoves = 0; });
            diceContributions = []; specialMoveContributions = [];
            expertise = 0; specialMoves = 0;
            rolls = []; outcomeText = "";
            isRolling = false; hasRolledThisTurn = false;
            currentRollIndex = null; currentAnimatedValue = null;

            if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId);
            sequenceChainTimeoutId = null;

            canPushLuck = false; canPayPrice = false;
            pushedLuckDieRoll = null; isRedoingRollAfterPrice = false;
            indexOfRollToRedo = -1;
            currentSequenceTotalDice = 0;
            
            resetTensionTimer(); 
            fullUIUpdate();
        }

        function handlePushLuck() {
            if (!canPushLuck) return;
            if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId); 
            sequenceChainTimeoutId = null;
            pushedLuckDieRoll = Math.floor(Math.random() * 6) + 1;
            canPushLuck = false; 
            if (pushedLuckDieRoll <= 3) {
                outcomeText = "Push Your Luck Failed! Original success potentially undone, complication added.";
            } else {
                outcomeText = "Push Your Luck Succeeded! Advantage pressed further.";
            }
            if (pushedLuckDieRoll === 6 && countdownClock < 99) { 
                 countdownClock++;
                 outcomeText += " (+1 to Countdown Clock)";
            } else if (pushedLuckDieRoll === 1 && countdownClock > 0) {
                 countdownClock--;
                 outcomeText += " (-1 to Countdown Clock)";
            }
            isRolling = false; 
            hasRolledThisTurn = true; 
            fullUIUpdate();
        }

         function handlePayPrice() {
            if (!canPayPrice) return;
            const pricePaidDescription = prompt("Describe the price you pay (e.g., lose supplies, take stress, alert enemies):");
            if (pricePaidDescription === null) return; 
            if (pricePaidDescription.trim() === "") {
                alert("You must describe a price to pay.");
                return;
            }
            if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId); 
            sequenceChainTimeoutId = null;
            canPayPrice = false; 
            isRedoingRollAfterPrice = true;
            if(indexOfRollToRedo === -1) { 
                 alert("Error: Could not identify which roll to redo. Resetting.");
                 clearAllContributionsAndStatsJS();
                 return;
            }
            outcomeText = `Price Paid: ${pricePaidDescription}. Redo the roll of 1.`;
            pushedLuckDieRoll = null; 
            isRolling = false; 
            fullUIUpdate();
        }

        function startRollingJS() {
            if (rollDiceBtn.classList.contains('reset-mode')) {
                clearAllContributionsAndStatsJS();
                return;
            }
            if (isTensionTimerRunning) {
                pauseTensionTimer();
            }
            if (isRedoingRollAfterPrice) {
                if (indexOfRollToRedo === -1) {
                    alert("Error: Cannot redo roll, index invalid.");
                    isRedoingRollAfterPrice = false; fullUIUpdate(); return;
                }
                isRolling = true; 
                outcomeText = ""; 
                currentAnimatedValue = null;
                currentRollIndex = indexOfRollToRedo; 
                renderDicePool(); 
                let animationCounter = 0;
                const animationIntervalId = setInterval(() => {
                    currentAnimatedValue = Math.floor(Math.random() * 6) + 1;
                    renderDicePool(); 
                    animationCounter++;
                    if (animationCounter >= SINGLE_DIE_ANIMATION_FRAMES) {
                        clearInterval(animationIntervalId);
                        const newDieRoll = Math.floor(Math.random() * 6) + 1;
                        rolls[indexOfRollToRedo] = newDieRoll; 
                        currentAnimatedValue = newDieRoll;
                        renderDicePool(); 
                        if (newDieRoll === 6 && countdownClock < 99) countdownClock++;
                        else if (newDieRoll === 1 && countdownClock > 0) countdownClock--;
                        const redoDisplayPauseTimeout = setTimeout(() => {
                            currentAnimatedValue = null; 
                            isRolling = false;
                            isRedoingRollAfterPrice = false; 
                            determineSingleDieOpportunity(newDieRoll); 
                            if (canPushLuck || canPayPrice) {
                                hasRolledThisTurn = true; 
                                if(canPayPrice) indexOfRollToRedo = currentRollIndex; 
                                fullUIUpdate();
                            } else {
                                const dieSlotThatWasRedone = indexOfRollToRedo;
                                indexOfRollToRedo = -1; 
                                outcomeText = ""; 
                                const nextDieInOriginalSequence = dieSlotThatWasRedone + 1;
                                if (nextDieInOriginalSequence < currentSequenceTotalDice) {
                                    isRolling = true; 
                                    fullUIUpdate(); 
                                    sequenceChainTimeoutId = setTimeout(() => {
                                        if(isRolling) { 
                                            processNextDieInSequence(nextDieInOriginalSequence, currentSequenceTotalDice);
                                        }
                                    }, SINGLE_DIE_POST_ANIMATION_PAUSE / 2); 
                                } else {
                                    finalizeOverallOutcome(rolls);
                                    hasRolledThisTurn = true;
                                    fullUIUpdate();
                                }
                            }
                        }, SINGLE_DIE_POST_ANIMATION_PAUSE);
                    }
                }, SINGLE_DIE_ANIMATION_INTERVAL);
                return;
            }
            const currentDicePool = getDicePool();
            const numSMCovers = getNumSpecialMovesVisuallyCoveringSlots();
             if (currentDicePool === 0) { 
                if (difficulty > 0 && numSMCovers >= difficulty) { 
                     outcomeText = "Success! Difficulty covered by special moves, no roll needed.";
                     finalizeOverallOutcome([]); 
                     hasRolledThisTurn = true;
                } else if (difficulty > 0 && numSMCovers < difficulty) { 
                    outcomeText = "Cannot roll: Need more expertise or special moves for this difficulty.";
                    hasRolledThisTurn = false; 
                } else { 
                    outcomeText = "Difficulty is 0, automatic success assumed. No roll needed.";
                     finalizeOverallOutcome([]);
                     hasRolledThisTurn = true;
                }
                isRolling = false; fullUIUpdate(); return;
            }
            if (expertise < getNumPrimarySlotsForExpertiseOrEmpty()) {
                outcomeText = `Cannot roll: Need ${getNumPrimarySlotsForExpertiseOrEmpty() - expertise} more expertise.`;
                hasRolledThisTurn = false;
                isRolling = false; fullUIUpdate(); return;
            }
            rolls = []; 
            for(let i=0; i < currentDicePool; ++i) rolls.push(undefined); 
            outcomeText = ""; 
            canPushLuck = false; canPayPrice = false; pushedLuckDieRoll = null;
            if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId);
            sequenceChainTimeoutId = null;
            isRolling = true; hasRolledThisTurn = false; 
            currentRollIndex = 0;
            currentAnimatedValue = null;
            currentSequenceTotalDice = currentDicePool; 
            fullUIUpdate(); 
            processNextDieInSequence(0, currentSequenceTotalDice);
        }

        function processNextDieInSequence(rollIdx, totalDiceInPool) {
            if (!isRolling) { 
                if (sequenceChainTimeoutId) clearTimeout(sequenceChainTimeoutId);
                sequenceChainTimeoutId = null;
                return;
            }
            if (canPushLuck || canPayPrice) { 
                isRolling = false; 
                hasRolledThisTurn = true; 
                fullUIUpdate();
                return;
            }
            currentRollIndex = rollIdx;
            currentAnimatedValue = null; 
            renderDicePool(); 
            let animationCounter = 0;
            const animationIntervalId = setInterval(() => {
                if (!isRolling) { 
                    clearInterval(animationIntervalId);
                    return;
                }
                currentAnimatedValue = Math.floor(Math.random() * 6) + 1;
                renderDicePool(); 
                animationCounter++;
                if (animationCounter >= SINGLE_DIE_ANIMATION_FRAMES) {
                    clearInterval(animationIntervalId);
                    const currentDieRoll = Math.floor(Math.random() * 6) + 1;
                    rolls[rollIdx] = currentDieRoll;
                    currentAnimatedValue = currentDieRoll;
                    renderDicePool(); 
                    if (currentDieRoll === 6 && countdownClock < 99) { 
                        countdownClock++;
                    } else if (currentDieRoll === 1 && countdownClock > 0) {
                        countdownClock--;
                    }
                    const postAnimationPauseTimeout = setTimeout(() => {
                        if (!isRolling && !(canPushLuck || canPayPrice)) { 
                             currentAnimatedValue = null; renderDicePool(); return;
                        }
                        currentAnimatedValue = null; 
                        renderDicePool(); 
                        determineSingleDieOpportunity(currentDieRoll);
                        if (canPushLuck || canPayPrice) {
                            isRolling = false; 
                            hasRolledThisTurn = true; 
                            if (canPayPrice) {
                                indexOfRollToRedo = rollIdx; 
                            }
                            fullUIUpdate(); 
                            return;
                        }
                        const isLastDieInSequence = (rollIdx + 1) >= totalDiceInPool;
                        if (isLastDieInSequence) {
                            isRolling = false;
                            currentRollIndex = null; 
                            finalizeOverallOutcome(rolls);
                            hasRolledThisTurn = true;
                            fullUIUpdate();
                        } else {
                            const delayForNextDie = BASE_DELAY_AFTER_DIE_FINISHES + (rollIdx * DELAY_INCREMENT_PER_DIE);
                            sequenceChainTimeoutId = setTimeout(() => {
                                if (isRolling) { 
                                    processNextDieInSequence(rollIdx + 1, totalDiceInPool);
                                }
                            }, delayForNextDie);
                        }
                    }, SINGLE_DIE_POST_ANIMATION_PAUSE);
                }
            }, SINGLE_DIE_ANIMATION_INTERVAL);
        }

        decreaseDifficultyBtn.addEventListener('click', () => { 
            if (!isRolling && !hasRolledThisTurn && !canPushLuck && !canPayPrice) { 
                difficulty = Math.max(0, difficulty - 1); 
                fullUIUpdate(); 
            }
        });
        increaseDifficultyBtn.addEventListener('click', () => { 
            if (!isRolling && !hasRolledThisTurn && !canPushLuck && !canPayPrice) { 
                difficulty += 1; 
                fullUIUpdate(); 
            }
        });

        startTensionTimerBtn.addEventListener('click', startTensionTimer);
        pauseTensionTimerBtn.addEventListener('click', pauseTensionTimer);
        resetTensionTimerBtn.addEventListener('click', resetTensionTimer);
        
        decreaseCountdownBtn.addEventListener('click', () => adjustCountdownClock(-1));
        increaseCountdownBtn.addEventListener('click', () => adjustCountdownClock(1));
        resetCountdownBtn.addEventListener('click', resetCountdownClock);

        openAddPlayerModalBtn.addEventListener('click', () => { addPlayerModalEl.style.display = 'flex'; });
        cancelAddPlayerBtn.addEventListener('click', () => {
            addPlayerModalEl.style.display = 'none'; playerNameInput.value = ''; playerImageInput.value = '';
            uploadedImage = null; imagePreviewContainer.style.display = 'none'; imagePreviewEl.src = '#';
        });
        confirmAddPlayerBtn.addEventListener('click', addPlayerJS);
        playerImageInput.addEventListener('change', handleImageUploadJS);
        rollDiceBtn.addEventListener('click', startRollingJS);
        pushLuckBtn.addEventListener('click', handlePushLuck);
        payPriceBtn.addEventListener('click', handlePayPrice);

        // Calculate perimeter for tension timer SVG border *after* DOM is fully loaded and styled
        // Use a slight delay if clientWidth/Height are 0 initially
        setTimeout(() => {
            const containerWidth = tensionTimerVisualContainer.clientWidth;
            const containerHeight = tensionTimerVisualContainer.clientHeight;
            const strokeWidth = 6; // Must match CSS
            const rectEffectiveWidth = containerWidth - strokeWidth;
            const rectEffectiveHeight = containerHeight - strokeWidth;
            tensionTimerBorderPerimeter = 2 * (rectEffectiveWidth + rectEffectiveHeight);
            if (tensionTimerBorderPerimeter > 0) { // Ensure it's calculated
                 tensionTimerSvgBorderRectEl.style.strokeDasharray = tensionTimerBorderPerimeter;
            } else {
                // Fallback or retry if dimensions not ready
                console.warn("Tension timer dimensions not ready for perimeter calculation on init.");
                tensionTimerBorderPerimeter = 300; // Arbitrary fallback
                tensionTimerSvgBorderRectEl.style.strokeDasharray = tensionTimerBorderPerimeter;
            }
            fullUIUpdate(); // Initial render with correct perimeter
        }, 50);


    });
  </script>
</body>
</html>
